{
  "id": "d24bf144-1c89-4157-bc52-3509ebb42216",
  "title": "Fix Daily Notes Folder Path",
  "titleGenerationStatus": "success",
  "createdAt": 1769618156656,
  "updatedAt": 1769621484847,
  "lastResponseAt": 1769621007195,
  "sessionId": "d24bf144-1c89-4157-bc52-3509ebb42216",
  "sdkSessionId": "d24bf144-1c89-4157-bc52-3509ebb42216",
  "usage": {
    "model": "claude-opus-4-5-20251101",
    "inputTokens": 114,
    "cacheCreationInputTokens": 104260,
    "cacheReadInputTokens": 1385656,
    "contextWindow": 200000,
    "contextTokens": 1490030,
    "percentage": 100
  },
  "toolDiffData": {
    "toolu_01JTmgJXTNqCNCZVDUNcpsgZ": {
      "filePath": "/Users/karthik/Documents/3 - Resources/Vaults/SecondBrain26/.obsidian/plugins/periodic-notes/data.json",
      "originalContent": "{\n  \"showGettingStartedBanner\": true,\n  \"hasMigratedDailyNoteSettings\": true,\n  \"hasMigratedWeeklyNoteSettings\": false,\n  \"daily\": {\n    \"format\": \"YYYY-MM-DD\",\n    \"folder\": \"Daily/{{date:YYYY}}/{{date:MM}}\",\n    \"template\": \"Templates/Daily\",\n    \"enabled\": true\n  },\n  \"weekly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"monthly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"quarterly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"yearly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  }\n}",
      "newContent": "{\n  \"showGettingStartedBanner\": true,\n  \"hasMigratedDailyNoteSettings\": true,\n  \"hasMigratedWeeklyNoteSettings\": false,\n  \"daily\": {\n    \"format\": \"YYYY-MM-DD\",\n    \"folder\": \"Daily/YYYY/MM\",\n    \"template\": \"Templates/Daily\",\n    \"enabled\": true\n  },\n  \"weekly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"monthly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"quarterly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"yearly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  }\n}"
    },
    "toolu_01RqoRXQ6dwSs72ZKbCd99Rc": {
      "filePath": "/Users/karthik/Documents/3 - Resources/Vaults/SecondBrain26/.obsidian/plugins/periodic-notes/data.json",
      "originalContent": "{\n  \"showGettingStartedBanner\": true,\n  \"hasMigratedDailyNoteSettings\": true,\n  \"hasMigratedWeeklyNoteSettings\": false,\n  \"daily\": {\n    \"format\": \"YYYY-MM-DD\",\n    \"folder\": \"Daily/YYYY/MM\",\n    \"template\": \"Templates/Daily\",\n    \"enabled\": true\n  },\n  \"weekly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"monthly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"quarterly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"yearly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  }\n}",
      "newContent": "{\n  \"showGettingStartedBanner\": true,\n  \"hasMigratedDailyNoteSettings\": true,\n  \"hasMigratedWeeklyNoteSettings\": false,\n  \"daily\": {\n    \"format\": \"YYYY-MM-DD\",\n    \"folder\": \"Daily/YYYY/MM\",\n    \"template\": \"Templates/Daily.md\",\n    \"enabled\": true\n  },\n  \"weekly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"monthly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"quarterly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"yearly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  }\n}"
    },
    "toolu_013c2HzezzB7Ar967ViNkNgQ": {
      "filePath": ".obsidian/core-plugins.json",
      "originalContent": "{\n  \"file-explorer\": true,\n  \"global-search\": true,\n  \"switcher\": true,\n  \"graph\": true,\n  \"backlink\": true,\n  \"canvas\": true,\n  \"outgoing-link\": true,\n  \"tag-pane\": true,\n  \"footnotes\": false,\n  \"properties\": true,\n  \"page-preview\": true,\n  \"daily-notes\": false,\n  \"templates\": true,\n  \"note-composer\": true,\n  \"command-palette\": true,\n  \"slash-command\": false,\n  \"editor-status\": true,\n  \"bookmarks\": true,\n  \"markdown-importer\": false,\n  \"zk-prefixer\": false,\n  \"random-note\": false,\n  \"outline\": true,\n  \"word-count\": true,\n  \"slides\": false,\n  \"audio-recorder\": false,\n  \"workspaces\": false,\n  \"file-recovery\": true,\n  \"publish\": false,\n  \"sync\": true,\n  \"bases\": true,\n  \"webviewer\": false\n}",
      "newContent": "{\n  \"file-explorer\": true,\n  \"global-search\": true,\n  \"switcher\": true,\n  \"graph\": true,\n  \"backlink\": true,\n  \"canvas\": true,\n  \"outgoing-link\": true,\n  \"tag-pane\": true,\n  \"footnotes\": false,\n  \"properties\": true,\n  \"page-preview\": true,\n  \"daily-notes\": true,\n  \"templates\": true,\n  \"note-composer\": true,\n  \"command-palette\": true,\n  \"slash-command\": false,\n  \"editor-status\": true,\n  \"bookmarks\": true,\n  \"markdown-importer\": false,\n  \"zk-prefixer\": false,\n  \"random-note\": false,\n  \"outline\": true,\n  \"word-count\": true,\n  \"slides\": false,\n  \"audio-recorder\": false,\n  \"workspaces\": false,\n  \"file-recovery\": true,\n  \"publish\": false,\n  \"sync\": true,\n  \"bases\": true,\n  \"webviewer\": false\n}"
    },
    "toolu_01UqjTStPy9PGjmriahPmAr3": {
      "filePath": ".obsidian/daily-notes.json",
      "originalContent": "{\n  \"folder\": \"Daily/2026/01\",\n  \"format\": \"YYYY-MM-DD\",\n  \"template\": \"Templates/Daily\"\n}",
      "newContent": "{\n  \"folder\": \"Daily\",\n  \"format\": \"YYYY-MM-DD\",\n  \"template\": \"Templates/Daily.md\"\n}"
    },
    "toolu_014PgUj44C8AaoMtJHiC3Vqe": {
      "filePath": ".obsidian/community-plugins.json",
      "originalContent": "[\n  \"obsidian42-brat\",\n  \"claudian\",\n  \"obsidian-things3-sync\",\n  \"things3-today\",\n  \"obsidian-tasks-plugin\",\n  \"templater-obsidian\",\n  \"obsidian-tracker\",\n  \"dataview\",\n  \"things-logbook\",\n  \"obsidian-paste-image-rename\",\n  \"periodic-notes\"\n]",
      "newContent": "[\n  \"obsidian42-brat\",\n  \"claudian\",\n  \"obsidian-things3-sync\",\n  \"things3-today\",\n  \"obsidian-tasks-plugin\",\n  \"templater-obsidian\",\n  \"obsidian-tracker\",\n  \"dataview\",\n  \"things-logbook\",\n  \"obsidian-paste-image-rename\"\n]"
    },
    "toolu_0118CoUjeA1dbdKzAf1CvQxC": {
      "filePath": "cli.sh",
      "originalContent": "#!/bin/bash\n# cli.sh - Bootstrap script for obsidian-cli + custom commands\n# Downloads the appropriate binary on first run\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"$0\")\" && pwd)\"\nCLI_DIR=\"$SCRIPT_DIR/.cli\"\nVERSION=\"0.2.0\"\nGITHUB_RELEASE=\"https://github.com/Yakitrak/obsidian-cli/releases/download/v${VERSION}\"\n\ndetect_platform() {\n  case \"$(uname -s)\" in\n    Darwin*)\n      echo \"darwin_all\"\n      ;;\n    Linux*)\n      case \"$(uname -m)\" in\n        x86_64)  echo \"linux_amd64\" ;;\n        aarch64|arm64) echo \"linux_arm64\" ;;\n        *) echo \"Unsupported architecture: $(uname -m)\" >&2; exit 1 ;;\n      esac\n      ;;\n    *)\n      echo \"Unsupported OS: $(uname -s)\" >&2\n      exit 1\n      ;;\n  esac\n}\n\nensure_binary() {\n  local platform=$(detect_platform)\n  local binary=\"$CLI_DIR/obsidian-cli\"\n  local tarball=\"obsidian-cli_${VERSION}_${platform}.tar.gz\"\n  local url=\"$GITHUB_RELEASE/$tarball\"\n\n  if [ ! -x \"$binary\" ]; then\n    echo \"Downloading obsidian-cli v${VERSION} for ${platform}...\" >&2\n    mkdir -p \"$CLI_DIR\"\n\n    if command -v curl &> /dev/null; then\n      curl -fsSL \"$url\" | tar -xz -C \"$CLI_DIR\"\n    elif command -v wget &> /dev/null; then\n      wget -qO- \"$url\" | tar -xz -C \"$CLI_DIR\"\n    else\n      echo \"Error: curl or wget required\" >&2\n      exit 1\n    fi\n\n    chmod +x \"$binary\"\n    echo \"Installed to $CLI_DIR\" >&2\n  fi\n}\n\n# === Git Remote Handling ===\n\n# Extract GitHub repo from current remote (handles various URL formats)\nget_github_repo() {\n  local remote=$(git remote get-url origin 2>/dev/null || echo \"\")\n  local repo=\"\"\n\n  # Extract owner/repo from various formats:\n  # - https://github.com/owner/repo.git\n  # - git@github.com:owner/repo.git\n  # - http://proxy@127.0.0.1:PORT/git/owner/repo\n\n  if echo \"$remote\" | grep -q \"github.com\"; then\n    repo=$(echo \"$remote\" | sed -E 's|.*github\\.com[:/]||' | sed 's|\\.git$||')\n  elif echo \"$remote\" | grep -q \"/git/\"; then\n    repo=$(echo \"$remote\" | sed -E 's|.*/git/||')\n  fi\n\n  echo \"$repo\"\n}\n\n# Ensure remote origin points directly to GitHub (not through proxy)\nensure_remote() {\n  local current_remote=$(git remote get-url origin 2>/dev/null || echo \"\")\n  local repo=$(get_github_repo)\n\n  if [ -z \"$repo\" ]; then\n    echo \"ERROR: Could not determine GitHub repo from remote\" >&2\n    echo \"Current remote: $current_remote\" >&2\n    exit 1\n  fi\n\n  # Check if remote is already correct (github.com, not proxy)\n  if echo \"$current_remote\" | grep -q \"github.com\"; then\n    return 0\n  fi\n\n  # Need to fix remote - check for GH_TOKEN\n  if [ -z \"$GH_TOKEN\" ]; then\n    echo \"ERROR: Remote needs fixing but GH_TOKEN is not set\" >&2\n    echo \"Current remote: $current_remote\" >&2\n    echo \"\" >&2\n    echo \"To fix: set GH_TOKEN environment variable with your GitHub token\" >&2\n    exit 1\n  fi\n\n  local auth_remote=\"https://x-access-token:${GH_TOKEN}@github.com/${repo}.git\"\n\n  echo \"Fixing remote origin...\"\n  echo \"  Was: $current_remote\"\n  echo \"  Now: https://***@github.com/${repo}.git\"\n\n  git remote set-url origin \"$auth_remote\"\n}\n\n# Ensure main branch exists locally\nensure_main_branch() {\n  # Check if main exists locally\n  if git show-ref --verify --quiet refs/heads/main; then\n    return 0\n  fi\n\n  echo \"Branch 'main' not found locally. Fetching...\"\n\n  # Try to fetch main from origin\n  if git fetch origin main:main 2>/dev/null; then\n    echo \"Fetched 'main' from origin.\"\n  else\n    # Maybe we need to create it from current HEAD\n    echo \"Creating 'main' branch from current HEAD...\"\n    git branch main\n  fi\n}\n\ncmd_sync() {\n  cd \"$SCRIPT_DIR\"\n\n  # Ensure remote is configured correctly\n  ensure_remote\n\n  # Ensure main branch exists\n  ensure_main_branch\n\n  # Check current branch\n  current_branch=$(git branch --show-current)\n\n  # Switch to main if needed\n  if [ \"$current_branch\" != \"main\" ]; then\n    echo \"Switching from '$current_branch' to 'main'...\"\n    git checkout main\n  fi\n\n  # Check for uncommitted changes\n  if git diff --quiet && git diff --staged --quiet; then\n    # Check for untracked files\n    if [ -z \"$(git ls-files --others --exclude-standard)\" ]; then\n      echo \"Nothing to sync.\"\n      exit 0\n    fi\n  fi\n\n  # Stage all changes\n  git add -A\n\n  # Commit with timestamp\n  timestamp=$(date '+%Y-%m-%d %H:%M')\n  git commit -m \"sync: $timestamp\"\n\n  echo \"Committed. Pushing to main...\"\n\n  # Try to push\n  if git push origin main 2>&1; then\n    echo \"Synced successfully.\"\n  else\n    echo \"\"\n    echo \"=== PUSH FAILED ===\"\n    echo \"Conflict detected. Pulling with rebase...\"\n    echo \"\"\n\n    # Try to pull and rebase\n    if git pull --rebase origin main 2>&1; then\n      echo \"Rebase successful. Pushing again...\"\n      if git push origin main 2>&1; then\n        echo \"Synced successfully after rebase.\"\n      else\n        echo \"\"\n        echo \"=== CRITICAL: Push still failing ===\"\n        echo \"Manual intervention required. Current status:\"\n        git status\n        exit 1\n      fi\n    else\n      echo \"\"\n      echo \"=== CRITICAL: Rebase conflict ===\"\n      echo \"Manual intervention required.\"\n      echo \"\"\n      echo \"Conflicting files:\"\n      git diff --name-only --diff-filter=U\n      echo \"\"\n      echo \"To resolve:\"\n      echo \"1. Edit conflicting files\"\n      echo \"2. git add <resolved files>\"\n      echo \"3. git rebase --continue\"\n      echo \"4. ./cli.sh sync\"\n      exit 1\n    fi\n  fi\n}\n\ncmd_read() {\n  cd \"$SCRIPT_DIR\"\n  local query=\"$1\"\n\n  if [ -z \"$query\" ]; then\n    echo \"Usage: ./cli.sh read <note-name or path>\" >&2\n    exit 1\n  fi\n\n  # Find the file\n  local file=\"\"\n\n  # If it's a direct path that exists\n  if [ -f \"$query\" ]; then\n    file=\"$query\"\n  elif [ -f \"$query.md\" ]; then\n    file=\"$query.md\"\n  else\n    # Search for Obsidian-style note name\n    file=$(find . -name \"*.md\" -type f | grep -i \"$query\" | head -1)\n  fi\n\n  if [ -z \"$file\" ] || [ ! -f \"$file\" ]; then\n    echo \"Note not found: $query\" >&2\n    exit 1\n  fi\n\n  # Get the basename for backlink search\n  local basename=$(basename \"$file\" .md)\n\n  # Print file content with line numbers (same format as Claude Read tool)\n  local abs_path=\"$(cd \"$(dirname \"$file\")\" && pwd)/$(basename \"$file\")\"\n  echo \"=== $abs_path ===\"\n  echo \"\"\n  awk '{printf \"%6dâ†’%s\\n\", NR, $0}' \"$file\"\n\n  # Find and print backlinks\n  echo \"\"\n  echo \"=== Backlinks ===\"\n\n  local backlinks=$(grep -rn \"\\[\\[$basename\" --include=\"*.md\" . 2>/dev/null | grep -v \"^$file:\" || true)\n\n  if [ -n \"$backlinks\" ]; then\n    echo \"$backlinks\"\n  else\n    echo \"(no backlinks)\"\n  fi\n}\n\ncmd_tasks() {\n  cd \"$SCRIPT_DIR\"\n\n  local path_filter=\"\"\n  local tag_filter=\"\"\n  local show_all=false\n\n  # Parse arguments\n  while [[ $# -gt 0 ]]; do\n    case \"$1\" in\n      --p1|--p2|--p3)\n        tag_filter=\"${1#--}\"\n        shift\n        ;;\n      --next|--waiting|--someday)\n        tag_filter=\"${1#--}\"\n        shift\n        ;;\n      --all)\n        show_all=true\n        shift\n        ;;\n      -*)\n        echo \"Unknown option: $1\" >&2\n        echo \"Usage: ./cli.sh tasks [path] [--p1|--p2|--p3|--next|--waiting|--someday] [--all]\" >&2\n        exit 1\n        ;;\n      *)\n        path_filter=\"$1\"\n        shift\n        ;;\n    esac\n  done\n\n  # Build search path\n  local search_path=\".\"\n  if [ -n \"$path_filter\" ]; then\n    # Find directories matching the filter\n    search_path=$(find . -type d -iname \"*$path_filter*\" 2>/dev/null | head -1)\n    if [ -z \"$search_path\" ]; then\n      # Try as a direct path\n      if [ -d \"$path_filter\" ]; then\n        search_path=\"$path_filter\"\n      else\n        echo \"No directory matching: $path_filter\" >&2\n        exit 1\n      fi\n    fi\n  fi\n\n  echo \"=== Tasks in $search_path ===\"\n  echo \"\"\n\n  # Find all unchecked tasks\n  local tasks\n  tasks=$(grep -rn \"\\- \\[ \\]\" --include=\"*.md\" \"$search_path\" 2>/dev/null || true)\n\n  if [ -z \"$tasks\" ]; then\n    echo \"No open tasks found.\"\n    return 0\n  fi\n\n  # Filter by tag if specified\n  if [ -n \"$tag_filter\" ]; then\n    tasks=$(echo \"$tasks\" | grep -i \"#$tag_filter\" || true)\n    if [ -z \"$tasks\" ]; then\n      echo \"No tasks with #$tag_filter\"\n      return 0\n    fi\n    echo \"Filtered by: #$tag_filter\"\n    echo \"\"\n  fi\n\n  # Group and display\n  local current_file=\"\"\n  local count=0\n\n  echo \"$tasks\" | while IFS= read -r line; do\n    # Extract file path and line number\n    local file=$(echo \"$line\" | cut -d: -f1)\n    local linenum=$(echo \"$line\" | cut -d: -f2)\n    local content=$(echo \"$line\" | cut -d: -f3-)\n\n    # Clean up content - remove leading spaces and the checkbox\n    content=$(echo \"$content\" | sed 's/^[[:space:]]*- \\[ \\] //')\n\n    # Print file header if new file\n    if [ \"$file\" != \"$current_file\" ]; then\n      if [ -n \"$current_file\" ]; then\n        echo \"\"\n      fi\n      echo \"$file\"\n      current_file=\"$file\"\n    fi\n\n    # Highlight priority tags\n    if echo \"$content\" | grep -q \"#p1\"; then\n      echo \"  [!] $content\"\n    elif echo \"$content\" | grep -q \"#p2\"; then\n      echo \"  [*] $content\"\n    elif echo \"$content\" | grep -q \"#p3\"; then\n      echo \"  [-] $content\"\n    elif echo \"$content\" | grep -q \"#next\"; then\n      echo \"  [>] $content\"\n    elif echo \"$content\" | grep -q \"#waiting\"; then\n      echo \"  [?] $content\"\n    elif echo \"$content\" | grep -q \"#someday\"; then\n      echo \"  [~] $content\"\n    else\n      echo \"  [ ] $content\"\n    fi\n\n    count=$((count + 1))\n  done\n\n  echo \"\"\n  echo \"---\"\n  local total=$(echo \"$tasks\" | wc -l | tr -d ' ')\n  echo \"Total: $total tasks\"\n}\n\ncmd_things() {\n  local list=\"${1:-today}\"\n\n  case \"$list\" in\n    today)\n      echo \"=== Things 3: Today ===\"\n      osascript -e 'tell application \"Things3\"\n        set output to \"\"\n        repeat with t in to dos of list \"Today\"\n          set taskName to name of t\n          set taskArea to \"\"\n          set taskDue to \"\"\n          try\n            set taskArea to name of area of t\n          end try\n          try\n            set taskDue to due date of t as string\n          end try\n          if taskArea is not \"\" then\n            set output to output & \"[\" & taskArea & \"] \"\n          end if\n          set output to output & taskName\n          if taskDue is not \"\" then\n            set output to output & \" ðŸ“… \" & taskDue\n          end if\n          set output to output & \"\\n\"\n        end repeat\n        return output\n      end tell'\n      ;;\n    anytime)\n      echo \"=== Things 3: Anytime ===\"\n      osascript -e 'tell application \"Things3\"\n        set output to \"\"\n        repeat with t in to dos of list \"Anytime\"\n          set taskName to name of t\n          set taskArea to \"\"\n          try\n            set taskArea to name of area of t\n          end try\n          if taskArea is not \"\" then\n            set output to output & \"[\" & taskArea & \"] \"\n          end if\n          set output to output & taskName & \"\\n\"\n        end repeat\n        return output\n      end tell' | head -30\n      ;;\n    areas)\n      echo \"=== Things 3: Tasks by Area ===\"\n      osascript -e 'tell application \"Things3\"\n        set output to \"\"\n        repeat with a in areas\n          set areaName to name of a\n          set areaTasks to to dos of a\n          if (count of areaTasks) > 0 then\n            set output to output & \"\\n\" & areaName & \":\\n\"\n            repeat with t in areaTasks\n              set taskName to name of t\n              set output to output & \"  - \" & taskName & \"\\n\"\n            end repeat\n          end if\n        end repeat\n        return output\n      end tell'\n      ;;\n    *)\n      echo \"Usage: ./cli.sh things [today|anytime|areas]\"\n      ;;\n  esac\n}\n\ncmd_status() {\n  cd \"$SCRIPT_DIR\"\n\n  echo \"=== Git Status ===\"\n\n  # Branch\n  branch=$(git branch --show-current)\n  echo \"Branch: $branch\"\n\n  # Uncommitted changes\n  changes=$(git status --porcelain | wc -l | tr -d ' ')\n  if [ \"$changes\" -gt 0 ]; then\n    echo \"Uncommitted changes: $changes files\"\n    git status --short\n  else\n    echo \"Working tree clean.\"\n  fi\n\n  # Ahead/behind\n  git fetch origin main --quiet 2>/dev/null || true\n  ahead=$(git rev-list --count origin/main..HEAD 2>/dev/null || echo \"0\")\n  behind=$(git rev-list --count HEAD..origin/main 2>/dev/null || echo \"0\")\n\n  if [ \"$ahead\" -gt 0 ] || [ \"$behind\" -gt 0 ]; then\n    echo \"Ahead: $ahead, Behind: $behind\"\n  fi\n}\n\n# === Main ===\n\ncase \"${1:-}\" in\n  sync)\n    cmd_sync\n    ;;\n  status)\n    cmd_status\n    ;;\n  read)\n    cmd_read \"$2\"\n    ;;\n  tasks)\n    shift\n    cmd_tasks \"$@\"\n    ;;\n  things)\n    shift\n    cmd_things \"$@\"\n    ;;\n  help|--help|-h)\n    echo \"Usage: ./cli.sh <command>\"\n    echo \"\"\n    echo \"Custom commands:\"\n    echo \"  sync              Commit all changes and push to main\"\n    echo \"  status            Show git status summary\"\n    echo \"  read <note>       Read note with backlinks\"\n    echo \"  tasks [path]      List open tasks\"\n    echo \"        --p1/p2/p3  Filter by priority\"\n    echo \"        --next      Filter by #next tag\"\n    echo \"  things [list]     Query Things 3\"\n    echo \"        today       Today list (default)\"\n    echo \"        anytime     Anytime list\"\n    echo \"        areas       Tasks grouped by area\"\n    echo \"\"\n    echo \"Obsidian commands:\"\n    ensure_binary\n    \"$CLI_DIR/obsidian-cli\" --help\n    ;;\n  *)\n    ensure_binary\n    exec \"$CLI_DIR/obsidian-cli\" \"$@\"\n    ;;\nesac\n",
      "newContent": "#!/bin/bash\n# cli.sh - Bootstrap script for obsidian-cli + custom commands\n# Downloads the appropriate binary on first run\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"$0\")\" && pwd)\"\nCLI_DIR=\"$SCRIPT_DIR/.cli\"\nVERSION=\"0.2.0\"\nGITHUB_RELEASE=\"https://github.com/Yakitrak/obsidian-cli/releases/download/v${VERSION}\"\n\ndetect_platform() {\n  case \"$(uname -s)\" in\n    Darwin*)\n      echo \"darwin_all\"\n      ;;\n    Linux*)\n      case \"$(uname -m)\" in\n        x86_64)  echo \"linux_amd64\" ;;\n        aarch64|arm64) echo \"linux_arm64\" ;;\n        *) echo \"Unsupported architecture: $(uname -m)\" >&2; exit 1 ;;\n      esac\n      ;;\n    *)\n      echo \"Unsupported OS: $(uname -s)\" >&2\n      exit 1\n      ;;\n  esac\n}\n\nensure_binary() {\n  local platform=$(detect_platform)\n  local binary=\"$CLI_DIR/obsidian-cli\"\n  local tarball=\"obsidian-cli_${VERSION}_${platform}.tar.gz\"\n  local url=\"$GITHUB_RELEASE/$tarball\"\n\n  if [ ! -x \"$binary\" ]; then\n    echo \"Downloading obsidian-cli v${VERSION} for ${platform}...\" >&2\n    mkdir -p \"$CLI_DIR\"\n\n    if command -v curl &> /dev/null; then\n      curl -fsSL \"$url\" | tar -xz -C \"$CLI_DIR\"\n    elif command -v wget &> /dev/null; then\n      wget -qO- \"$url\" | tar -xz -C \"$CLI_DIR\"\n    else\n      echo \"Error: curl or wget required\" >&2\n      exit 1\n    fi\n\n    chmod +x \"$binary\"\n    echo \"Installed to $CLI_DIR\" >&2\n  fi\n}\n\n# === Git Remote Handling ===\n\n# Extract GitHub repo from current remote (handles various URL formats)\nget_github_repo() {\n  local remote=$(git remote get-url origin 2>/dev/null || echo \"\")\n  local repo=\"\"\n\n  # Extract owner/repo from various formats:\n  # - https://github.com/owner/repo.git\n  # - git@github.com:owner/repo.git\n  # - http://proxy@127.0.0.1:PORT/git/owner/repo\n\n  if echo \"$remote\" | grep -q \"github.com\"; then\n    repo=$(echo \"$remote\" | sed -E 's|.*github\\.com[:/]||' | sed 's|\\.git$||')\n  elif echo \"$remote\" | grep -q \"/git/\"; then\n    repo=$(echo \"$remote\" | sed -E 's|.*/git/||')\n  fi\n\n  echo \"$repo\"\n}\n\n# Ensure remote origin points directly to GitHub (not through proxy)\nensure_remote() {\n  local current_remote=$(git remote get-url origin 2>/dev/null || echo \"\")\n  local repo=$(get_github_repo)\n\n  if [ -z \"$repo\" ]; then\n    echo \"ERROR: Could not determine GitHub repo from remote\" >&2\n    echo \"Current remote: $current_remote\" >&2\n    exit 1\n  fi\n\n  # Check if remote is already correct (github.com, not proxy)\n  if echo \"$current_remote\" | grep -q \"github.com\"; then\n    return 0\n  fi\n\n  # Need to fix remote - check for GH_TOKEN\n  if [ -z \"$GH_TOKEN\" ]; then\n    echo \"ERROR: Remote needs fixing but GH_TOKEN is not set\" >&2\n    echo \"Current remote: $current_remote\" >&2\n    echo \"\" >&2\n    echo \"To fix: set GH_TOKEN environment variable with your GitHub token\" >&2\n    exit 1\n  fi\n\n  local auth_remote=\"https://x-access-token:${GH_TOKEN}@github.com/${repo}.git\"\n\n  echo \"Fixing remote origin...\"\n  echo \"  Was: $current_remote\"\n  echo \"  Now: https://***@github.com/${repo}.git\"\n\n  git remote set-url origin \"$auth_remote\"\n}\n\n# Ensure main branch exists locally\nensure_main_branch() {\n  # Check if main exists locally\n  if git show-ref --verify --quiet refs/heads/main; then\n    return 0\n  fi\n\n  echo \"Branch 'main' not found locally. Fetching...\"\n\n  # Try to fetch main from origin\n  if git fetch origin main:main 2>/dev/null; then\n    echo \"Fetched 'main' from origin.\"\n  else\n    # Maybe we need to create it from current HEAD\n    echo \"Creating 'main' branch from current HEAD...\"\n    git branch main\n  fi\n}\n\ncmd_sync() {\n  cd \"$SCRIPT_DIR\"\n\n  # Ensure remote is configured correctly\n  ensure_remote\n\n  # Ensure main branch exists\n  ensure_main_branch\n\n  # Check current branch\n  current_branch=$(git branch --show-current)\n\n  # Switch to main if needed\n  if [ \"$current_branch\" != \"main\" ]; then\n    echo \"Switching from '$current_branch' to 'main'...\"\n    git checkout main\n  fi\n\n  # Check for uncommitted changes\n  if git diff --quiet && git diff --staged --quiet; then\n    # Check for untracked files\n    if [ -z \"$(git ls-files --others --exclude-standard)\" ]; then\n      echo \"Nothing to sync.\"\n      exit 0\n    fi\n  fi\n\n  # Stage all changes\n  git add -A\n\n  # Commit with timestamp\n  timestamp=$(date '+%Y-%m-%d %H:%M')\n  git commit -m \"sync: $timestamp\"\n\n  echo \"Committed. Pushing to main...\"\n\n  # Try to push\n  if git push origin main 2>&1; then\n    echo \"Synced successfully.\"\n  else\n    echo \"\"\n    echo \"=== PUSH FAILED ===\"\n    echo \"Conflict detected. Pulling with rebase...\"\n    echo \"\"\n\n    # Try to pull and rebase\n    if git pull --rebase origin main 2>&1; then\n      echo \"Rebase successful. Pushing again...\"\n      if git push origin main 2>&1; then\n        echo \"Synced successfully after rebase.\"\n      else\n        echo \"\"\n        echo \"=== CRITICAL: Push still failing ===\"\n        echo \"Manual intervention required. Current status:\"\n        git status\n        exit 1\n      fi\n    else\n      echo \"\"\n      echo \"=== CRITICAL: Rebase conflict ===\"\n      echo \"Manual intervention required.\"\n      echo \"\"\n      echo \"Conflicting files:\"\n      git diff --name-only --diff-filter=U\n      echo \"\"\n      echo \"To resolve:\"\n      echo \"1. Edit conflicting files\"\n      echo \"2. git add <resolved files>\"\n      echo \"3. git rebase --continue\"\n      echo \"4. ./cli.sh sync\"\n      exit 1\n    fi\n  fi\n}\n\ncmd_read() {\n  cd \"$SCRIPT_DIR\"\n  local query=\"$1\"\n\n  if [ -z \"$query\" ]; then\n    echo \"Usage: ./cli.sh read <note-name or path>\" >&2\n    exit 1\n  fi\n\n  # Find the file\n  local file=\"\"\n\n  # If it's a direct path that exists\n  if [ -f \"$query\" ]; then\n    file=\"$query\"\n  elif [ -f \"$query.md\" ]; then\n    file=\"$query.md\"\n  else\n    # Search for Obsidian-style note name\n    file=$(find . -name \"*.md\" -type f | grep -i \"$query\" | head -1)\n  fi\n\n  if [ -z \"$file\" ] || [ ! -f \"$file\" ]; then\n    echo \"Note not found: $query\" >&2\n    exit 1\n  fi\n\n  # Get the basename for backlink search\n  local basename=$(basename \"$file\" .md)\n\n  # Print file content with line numbers (same format as Claude Read tool)\n  local abs_path=\"$(cd \"$(dirname \"$file\")\" && pwd)/$(basename \"$file\")\"\n  echo \"=== $abs_path ===\"\n  echo \"\"\n  awk '{printf \"%6dâ†’%s\\n\", NR, $0}' \"$file\"\n\n  # Find and print backlinks\n  echo \"\"\n  echo \"=== Backlinks ===\"\n\n  local backlinks=$(grep -rn \"\\[\\[$basename\" --include=\"*.md\" . 2>/dev/null | grep -v \"^$file:\" || true)\n\n  if [ -n \"$backlinks\" ]; then\n    echo \"$backlinks\"\n  else\n    echo \"(no backlinks)\"\n  fi\n}\n\ncmd_tasks() {\n  cd \"$SCRIPT_DIR\"\n\n  local path_filter=\"\"\n  local tag_filter=\"\"\n  local show_all=false\n\n  # Parse arguments\n  while [[ $# -gt 0 ]]; do\n    case \"$1\" in\n      --p1|--p2|--p3)\n        tag_filter=\"${1#--}\"\n        shift\n        ;;\n      --next|--waiting|--someday)\n        tag_filter=\"${1#--}\"\n        shift\n        ;;\n      --all)\n        show_all=true\n        shift\n        ;;\n      -*)\n        echo \"Unknown option: $1\" >&2\n        echo \"Usage: ./cli.sh tasks [path] [--p1|--p2|--p3|--next|--waiting|--someday] [--all]\" >&2\n        exit 1\n        ;;\n      *)\n        path_filter=\"$1\"\n        shift\n        ;;\n    esac\n  done\n\n  # Build search path\n  local search_path=\".\"\n  if [ -n \"$path_filter\" ]; then\n    # Find directories matching the filter\n    search_path=$(find . -type d -iname \"*$path_filter*\" 2>/dev/null | head -1)\n    if [ -z \"$search_path\" ]; then\n      # Try as a direct path\n      if [ -d \"$path_filter\" ]; then\n        search_path=\"$path_filter\"\n      else\n        echo \"No directory matching: $path_filter\" >&2\n        exit 1\n      fi\n    fi\n  fi\n\n  echo \"=== Tasks in $search_path ===\"\n  echo \"\"\n\n  # Find all unchecked tasks\n  local tasks\n  tasks=$(grep -rn \"\\- \\[ \\]\" --include=\"*.md\" \"$search_path\" 2>/dev/null || true)\n\n  if [ -z \"$tasks\" ]; then\n    echo \"No open tasks found.\"\n    return 0\n  fi\n\n  # Filter by tag if specified\n  if [ -n \"$tag_filter\" ]; then\n    tasks=$(echo \"$tasks\" | grep -i \"#$tag_filter\" || true)\n    if [ -z \"$tasks\" ]; then\n      echo \"No tasks with #$tag_filter\"\n      return 0\n    fi\n    echo \"Filtered by: #$tag_filter\"\n    echo \"\"\n  fi\n\n  # Group and display\n  local current_file=\"\"\n  local count=0\n\n  echo \"$tasks\" | while IFS= read -r line; do\n    # Extract file path and line number\n    local file=$(echo \"$line\" | cut -d: -f1)\n    local linenum=$(echo \"$line\" | cut -d: -f2)\n    local content=$(echo \"$line\" | cut -d: -f3-)\n\n    # Clean up content - remove leading spaces and the checkbox\n    content=$(echo \"$content\" | sed 's/^[[:space:]]*- \\[ \\] //')\n\n    # Print file header if new file\n    if [ \"$file\" != \"$current_file\" ]; then\n      if [ -n \"$current_file\" ]; then\n        echo \"\"\n      fi\n      echo \"$file\"\n      current_file=\"$file\"\n    fi\n\n    # Highlight priority tags\n    if echo \"$content\" | grep -q \"#p1\"; then\n      echo \"  [!] $content\"\n    elif echo \"$content\" | grep -q \"#p2\"; then\n      echo \"  [*] $content\"\n    elif echo \"$content\" | grep -q \"#p3\"; then\n      echo \"  [-] $content\"\n    elif echo \"$content\" | grep -q \"#next\"; then\n      echo \"  [>] $content\"\n    elif echo \"$content\" | grep -q \"#waiting\"; then\n      echo \"  [?] $content\"\n    elif echo \"$content\" | grep -q \"#someday\"; then\n      echo \"  [~] $content\"\n    else\n      echo \"  [ ] $content\"\n    fi\n\n    count=$((count + 1))\n  done\n\n  echo \"\"\n  echo \"---\"\n  local total=$(echo \"$tasks\" | wc -l | tr -d ' ')\n  echo \"Total: $total tasks\"\n}\n\ncmd_daily() {\n  cd \"$SCRIPT_DIR\"\n\n  # Get current date\n  local year=$(date '+%Y')\n  local month=$(date '+%m')\n  local date_str=$(date '+%Y-%m-%d')\n\n  # Ensure directory exists\n  local daily_dir=\"Daily/$year/$month\"\n  mkdir -p \"$daily_dir\"\n\n  # Ensure Briefs subfolder exists\n  mkdir -p \"$daily_dir/Briefs\"\n\n  # Create the daily note file\n  local daily_file=\"$daily_dir/$date_str.md\"\n\n  # Check if file already exists\n  if [ -f \"$daily_file\" ]; then\n    echo \"Daily note already exists: $daily_file\"\n  else\n    # Copy template if it exists\n    if [ -f \"Templates/Daily.md\" ]; then\n      cp \"Templates/Daily.md\" \"$daily_file\"\n      echo \"Created daily note: $daily_file\"\n    else\n      # Create basic template if none exists\n      cat > \"$daily_file\" << EOF\n# $date_str\n\n## ðŸŽ¯ #1 Priority\n\n## Workspace\n\n### Deep Work\n\n### Capture\n\n## Logbook\n\nEOF\n      echo \"Created daily note: $daily_file\"\n    fi\n  fi\n\n  # Open in Obsidian\n  \"$CLI_DIR/obsidian-cli\" open \"$daily_file\"\n}\n\ncmd_things() {\n  local list=\"${1:-today}\"\n\n  case \"$list\" in\n    today)\n      echo \"=== Things 3: Today ===\"\n      osascript -e 'tell application \"Things3\"\n        set output to \"\"\n        repeat with t in to dos of list \"Today\"\n          set taskName to name of t\n          set taskArea to \"\"\n          set taskDue to \"\"\n          try\n            set taskArea to name of area of t\n          end try\n          try\n            set taskDue to due date of t as string\n          end try\n          if taskArea is not \"\" then\n            set output to output & \"[\" & taskArea & \"] \"\n          end if\n          set output to output & taskName\n          if taskDue is not \"\" then\n            set output to output & \" ðŸ“… \" & taskDue\n          end if\n          set output to output & \"\\n\"\n        end repeat\n        return output\n      end tell'\n      ;;\n    anytime)\n      echo \"=== Things 3: Anytime ===\"\n      osascript -e 'tell application \"Things3\"\n        set output to \"\"\n        repeat with t in to dos of list \"Anytime\"\n          set taskName to name of t\n          set taskArea to \"\"\n          try\n            set taskArea to name of area of t\n          end try\n          if taskArea is not \"\" then\n            set output to output & \"[\" & taskArea & \"] \"\n          end if\n          set output to output & taskName & \"\\n\"\n        end repeat\n        return output\n      end tell' | head -30\n      ;;\n    areas)\n      echo \"=== Things 3: Tasks by Area ===\"\n      osascript -e 'tell application \"Things3\"\n        set output to \"\"\n        repeat with a in areas\n          set areaName to name of a\n          set areaTasks to to dos of a\n          if (count of areaTasks) > 0 then\n            set output to output & \"\\n\" & areaName & \":\\n\"\n            repeat with t in areaTasks\n              set taskName to name of t\n              set output to output & \"  - \" & taskName & \"\\n\"\n            end repeat\n          end if\n        end repeat\n        return output\n      end tell'\n      ;;\n    *)\n      echo \"Usage: ./cli.sh things [today|anytime|areas]\"\n      ;;\n  esac\n}\n\ncmd_status() {\n  cd \"$SCRIPT_DIR\"\n\n  echo \"=== Git Status ===\"\n\n  # Branch\n  branch=$(git branch --show-current)\n  echo \"Branch: $branch\"\n\n  # Uncommitted changes\n  changes=$(git status --porcelain | wc -l | tr -d ' ')\n  if [ \"$changes\" -gt 0 ]; then\n    echo \"Uncommitted changes: $changes files\"\n    git status --short\n  else\n    echo \"Working tree clean.\"\n  fi\n\n  # Ahead/behind\n  git fetch origin main --quiet 2>/dev/null || true\n  ahead=$(git rev-list --count origin/main..HEAD 2>/dev/null || echo \"0\")\n  behind=$(git rev-list --count HEAD..origin/main 2>/dev/null || echo \"0\")\n\n  if [ \"$ahead\" -gt 0 ] || [ \"$behind\" -gt 0 ]; then\n    echo \"Ahead: $ahead, Behind: $behind\"\n  fi\n}\n\n# === Main ===\n\ncase \"${1:-}\" in\n  sync)\n    cmd_sync\n    ;;\n  status)\n    cmd_status\n    ;;\n  read)\n    cmd_read \"$2\"\n    ;;\n  tasks)\n    shift\n    cmd_tasks \"$@\"\n    ;;\n  things)\n    shift\n    cmd_things \"$@\"\n    ;;\n  help|--help|-h)\n    echo \"Usage: ./cli.sh <command>\"\n    echo \"\"\n    echo \"Custom commands:\"\n    echo \"  sync              Commit all changes and push to main\"\n    echo \"  status            Show git status summary\"\n    echo \"  read <note>       Read note with backlinks\"\n    echo \"  tasks [path]      List open tasks\"\n    echo \"        --p1/p2/p3  Filter by priority\"\n    echo \"        --next      Filter by #next tag\"\n    echo \"  things [list]     Query Things 3\"\n    echo \"        today       Today list (default)\"\n    echo \"        anytime     Anytime list\"\n    echo \"        areas       Tasks grouped by area\"\n    echo \"\"\n    echo \"Obsidian commands:\"\n    ensure_binary\n    \"$CLI_DIR/obsidian-cli\" --help\n    ;;\n  *)\n    ensure_binary\n    exec \"$CLI_DIR/obsidian-cli\" \"$@\"\n    ;;\nesac\n"
    },
    "toolu_01379zqSmeSxjPjbF656F6Bb": {
      "filePath": "cli.sh",
      "originalContent": "#!/bin/bash\n# cli.sh - Bootstrap script for obsidian-cli + custom commands\n# Downloads the appropriate binary on first run\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"$0\")\" && pwd)\"\nCLI_DIR=\"$SCRIPT_DIR/.cli\"\nVERSION=\"0.2.0\"\nGITHUB_RELEASE=\"https://github.com/Yakitrak/obsidian-cli/releases/download/v${VERSION}\"\n\ndetect_platform() {\n  case \"$(uname -s)\" in\n    Darwin*)\n      echo \"darwin_all\"\n      ;;\n    Linux*)\n      case \"$(uname -m)\" in\n        x86_64)  echo \"linux_amd64\" ;;\n        aarch64|arm64) echo \"linux_arm64\" ;;\n        *) echo \"Unsupported architecture: $(uname -m)\" >&2; exit 1 ;;\n      esac\n      ;;\n    *)\n      echo \"Unsupported OS: $(uname -s)\" >&2\n      exit 1\n      ;;\n  esac\n}\n\nensure_binary() {\n  local platform=$(detect_platform)\n  local binary=\"$CLI_DIR/obsidian-cli\"\n  local tarball=\"obsidian-cli_${VERSION}_${platform}.tar.gz\"\n  local url=\"$GITHUB_RELEASE/$tarball\"\n\n  if [ ! -x \"$binary\" ]; then\n    echo \"Downloading obsidian-cli v${VERSION} for ${platform}...\" >&2\n    mkdir -p \"$CLI_DIR\"\n\n    if command -v curl &> /dev/null; then\n      curl -fsSL \"$url\" | tar -xz -C \"$CLI_DIR\"\n    elif command -v wget &> /dev/null; then\n      wget -qO- \"$url\" | tar -xz -C \"$CLI_DIR\"\n    else\n      echo \"Error: curl or wget required\" >&2\n      exit 1\n    fi\n\n    chmod +x \"$binary\"\n    echo \"Installed to $CLI_DIR\" >&2\n  fi\n}\n\n# === Git Remote Handling ===\n\n# Extract GitHub repo from current remote (handles various URL formats)\nget_github_repo() {\n  local remote=$(git remote get-url origin 2>/dev/null || echo \"\")\n  local repo=\"\"\n\n  # Extract owner/repo from various formats:\n  # - https://github.com/owner/repo.git\n  # - git@github.com:owner/repo.git\n  # - http://proxy@127.0.0.1:PORT/git/owner/repo\n\n  if echo \"$remote\" | grep -q \"github.com\"; then\n    repo=$(echo \"$remote\" | sed -E 's|.*github\\.com[:/]||' | sed 's|\\.git$||')\n  elif echo \"$remote\" | grep -q \"/git/\"; then\n    repo=$(echo \"$remote\" | sed -E 's|.*/git/||')\n  fi\n\n  echo \"$repo\"\n}\n\n# Ensure remote origin points directly to GitHub (not through proxy)\nensure_remote() {\n  local current_remote=$(git remote get-url origin 2>/dev/null || echo \"\")\n  local repo=$(get_github_repo)\n\n  if [ -z \"$repo\" ]; then\n    echo \"ERROR: Could not determine GitHub repo from remote\" >&2\n    echo \"Current remote: $current_remote\" >&2\n    exit 1\n  fi\n\n  # Check if remote is already correct (github.com, not proxy)\n  if echo \"$current_remote\" | grep -q \"github.com\"; then\n    return 0\n  fi\n\n  # Need to fix remote - check for GH_TOKEN\n  if [ -z \"$GH_TOKEN\" ]; then\n    echo \"ERROR: Remote needs fixing but GH_TOKEN is not set\" >&2\n    echo \"Current remote: $current_remote\" >&2\n    echo \"\" >&2\n    echo \"To fix: set GH_TOKEN environment variable with your GitHub token\" >&2\n    exit 1\n  fi\n\n  local auth_remote=\"https://x-access-token:${GH_TOKEN}@github.com/${repo}.git\"\n\n  echo \"Fixing remote origin...\"\n  echo \"  Was: $current_remote\"\n  echo \"  Now: https://***@github.com/${repo}.git\"\n\n  git remote set-url origin \"$auth_remote\"\n}\n\n# Ensure main branch exists locally\nensure_main_branch() {\n  # Check if main exists locally\n  if git show-ref --verify --quiet refs/heads/main; then\n    return 0\n  fi\n\n  echo \"Branch 'main' not found locally. Fetching...\"\n\n  # Try to fetch main from origin\n  if git fetch origin main:main 2>/dev/null; then\n    echo \"Fetched 'main' from origin.\"\n  else\n    # Maybe we need to create it from current HEAD\n    echo \"Creating 'main' branch from current HEAD...\"\n    git branch main\n  fi\n}\n\ncmd_sync() {\n  cd \"$SCRIPT_DIR\"\n\n  # Ensure remote is configured correctly\n  ensure_remote\n\n  # Ensure main branch exists\n  ensure_main_branch\n\n  # Check current branch\n  current_branch=$(git branch --show-current)\n\n  # Switch to main if needed\n  if [ \"$current_branch\" != \"main\" ]; then\n    echo \"Switching from '$current_branch' to 'main'...\"\n    git checkout main\n  fi\n\n  # Check for uncommitted changes\n  if git diff --quiet && git diff --staged --quiet; then\n    # Check for untracked files\n    if [ -z \"$(git ls-files --others --exclude-standard)\" ]; then\n      echo \"Nothing to sync.\"\n      exit 0\n    fi\n  fi\n\n  # Stage all changes\n  git add -A\n\n  # Commit with timestamp\n  timestamp=$(date '+%Y-%m-%d %H:%M')\n  git commit -m \"sync: $timestamp\"\n\n  echo \"Committed. Pushing to main...\"\n\n  # Try to push\n  if git push origin main 2>&1; then\n    echo \"Synced successfully.\"\n  else\n    echo \"\"\n    echo \"=== PUSH FAILED ===\"\n    echo \"Conflict detected. Pulling with rebase...\"\n    echo \"\"\n\n    # Try to pull and rebase\n    if git pull --rebase origin main 2>&1; then\n      echo \"Rebase successful. Pushing again...\"\n      if git push origin main 2>&1; then\n        echo \"Synced successfully after rebase.\"\n      else\n        echo \"\"\n        echo \"=== CRITICAL: Push still failing ===\"\n        echo \"Manual intervention required. Current status:\"\n        git status\n        exit 1\n      fi\n    else\n      echo \"\"\n      echo \"=== CRITICAL: Rebase conflict ===\"\n      echo \"Manual intervention required.\"\n      echo \"\"\n      echo \"Conflicting files:\"\n      git diff --name-only --diff-filter=U\n      echo \"\"\n      echo \"To resolve:\"\n      echo \"1. Edit conflicting files\"\n      echo \"2. git add <resolved files>\"\n      echo \"3. git rebase --continue\"\n      echo \"4. ./cli.sh sync\"\n      exit 1\n    fi\n  fi\n}\n\ncmd_read() {\n  cd \"$SCRIPT_DIR\"\n  local query=\"$1\"\n\n  if [ -z \"$query\" ]; then\n    echo \"Usage: ./cli.sh read <note-name or path>\" >&2\n    exit 1\n  fi\n\n  # Find the file\n  local file=\"\"\n\n  # If it's a direct path that exists\n  if [ -f \"$query\" ]; then\n    file=\"$query\"\n  elif [ -f \"$query.md\" ]; then\n    file=\"$query.md\"\n  else\n    # Search for Obsidian-style note name\n    file=$(find . -name \"*.md\" -type f | grep -i \"$query\" | head -1)\n  fi\n\n  if [ -z \"$file\" ] || [ ! -f \"$file\" ]; then\n    echo \"Note not found: $query\" >&2\n    exit 1\n  fi\n\n  # Get the basename for backlink search\n  local basename=$(basename \"$file\" .md)\n\n  # Print file content with line numbers (same format as Claude Read tool)\n  local abs_path=\"$(cd \"$(dirname \"$file\")\" && pwd)/$(basename \"$file\")\"\n  echo \"=== $abs_path ===\"\n  echo \"\"\n  awk '{printf \"%6dâ†’%s\\n\", NR, $0}' \"$file\"\n\n  # Find and print backlinks\n  echo \"\"\n  echo \"=== Backlinks ===\"\n\n  local backlinks=$(grep -rn \"\\[\\[$basename\" --include=\"*.md\" . 2>/dev/null | grep -v \"^$file:\" || true)\n\n  if [ -n \"$backlinks\" ]; then\n    echo \"$backlinks\"\n  else\n    echo \"(no backlinks)\"\n  fi\n}\n\ncmd_tasks() {\n  cd \"$SCRIPT_DIR\"\n\n  local path_filter=\"\"\n  local tag_filter=\"\"\n  local show_all=false\n\n  # Parse arguments\n  while [[ $# -gt 0 ]]; do\n    case \"$1\" in\n      --p1|--p2|--p3)\n        tag_filter=\"${1#--}\"\n        shift\n        ;;\n      --next|--waiting|--someday)\n        tag_filter=\"${1#--}\"\n        shift\n        ;;\n      --all)\n        show_all=true\n        shift\n        ;;\n      -*)\n        echo \"Unknown option: $1\" >&2\n        echo \"Usage: ./cli.sh tasks [path] [--p1|--p2|--p3|--next|--waiting|--someday] [--all]\" >&2\n        exit 1\n        ;;\n      *)\n        path_filter=\"$1\"\n        shift\n        ;;\n    esac\n  done\n\n  # Build search path\n  local search_path=\".\"\n  if [ -n \"$path_filter\" ]; then\n    # Find directories matching the filter\n    search_path=$(find . -type d -iname \"*$path_filter*\" 2>/dev/null | head -1)\n    if [ -z \"$search_path\" ]; then\n      # Try as a direct path\n      if [ -d \"$path_filter\" ]; then\n        search_path=\"$path_filter\"\n      else\n        echo \"No directory matching: $path_filter\" >&2\n        exit 1\n      fi\n    fi\n  fi\n\n  echo \"=== Tasks in $search_path ===\"\n  echo \"\"\n\n  # Find all unchecked tasks\n  local tasks\n  tasks=$(grep -rn \"\\- \\[ \\]\" --include=\"*.md\" \"$search_path\" 2>/dev/null || true)\n\n  if [ -z \"$tasks\" ]; then\n    echo \"No open tasks found.\"\n    return 0\n  fi\n\n  # Filter by tag if specified\n  if [ -n \"$tag_filter\" ]; then\n    tasks=$(echo \"$tasks\" | grep -i \"#$tag_filter\" || true)\n    if [ -z \"$tasks\" ]; then\n      echo \"No tasks with #$tag_filter\"\n      return 0\n    fi\n    echo \"Filtered by: #$tag_filter\"\n    echo \"\"\n  fi\n\n  # Group and display\n  local current_file=\"\"\n  local count=0\n\n  echo \"$tasks\" | while IFS= read -r line; do\n    # Extract file path and line number\n    local file=$(echo \"$line\" | cut -d: -f1)\n    local linenum=$(echo \"$line\" | cut -d: -f2)\n    local content=$(echo \"$line\" | cut -d: -f3-)\n\n    # Clean up content - remove leading spaces and the checkbox\n    content=$(echo \"$content\" | sed 's/^[[:space:]]*- \\[ \\] //')\n\n    # Print file header if new file\n    if [ \"$file\" != \"$current_file\" ]; then\n      if [ -n \"$current_file\" ]; then\n        echo \"\"\n      fi\n      echo \"$file\"\n      current_file=\"$file\"\n    fi\n\n    # Highlight priority tags\n    if echo \"$content\" | grep -q \"#p1\"; then\n      echo \"  [!] $content\"\n    elif echo \"$content\" | grep -q \"#p2\"; then\n      echo \"  [*] $content\"\n    elif echo \"$content\" | grep -q \"#p3\"; then\n      echo \"  [-] $content\"\n    elif echo \"$content\" | grep -q \"#next\"; then\n      echo \"  [>] $content\"\n    elif echo \"$content\" | grep -q \"#waiting\"; then\n      echo \"  [?] $content\"\n    elif echo \"$content\" | grep -q \"#someday\"; then\n      echo \"  [~] $content\"\n    else\n      echo \"  [ ] $content\"\n    fi\n\n    count=$((count + 1))\n  done\n\n  echo \"\"\n  echo \"---\"\n  local total=$(echo \"$tasks\" | wc -l | tr -d ' ')\n  echo \"Total: $total tasks\"\n}\n\ncmd_daily() {\n  cd \"$SCRIPT_DIR\"\n\n  # Get current date\n  local year=$(date '+%Y')\n  local month=$(date '+%m')\n  local date_str=$(date '+%Y-%m-%d')\n\n  # Ensure directory exists\n  local daily_dir=\"Daily/$year/$month\"\n  mkdir -p \"$daily_dir\"\n\n  # Ensure Briefs subfolder exists\n  mkdir -p \"$daily_dir/Briefs\"\n\n  # Create the daily note file\n  local daily_file=\"$daily_dir/$date_str.md\"\n\n  # Check if file already exists\n  if [ -f \"$daily_file\" ]; then\n    echo \"Daily note already exists: $daily_file\"\n  else\n    # Copy template if it exists\n    if [ -f \"Templates/Daily.md\" ]; then\n      cp \"Templates/Daily.md\" \"$daily_file\"\n      echo \"Created daily note: $daily_file\"\n    else\n      # Create basic template if none exists\n      cat > \"$daily_file\" << EOF\n# $date_str\n\n## ðŸŽ¯ #1 Priority\n\n## Workspace\n\n### Deep Work\n\n### Capture\n\n## Logbook\n\nEOF\n      echo \"Created daily note: $daily_file\"\n    fi\n  fi\n\n  # Open in Obsidian\n  \"$CLI_DIR/obsidian-cli\" open \"$daily_file\"\n}\n\ncmd_things() {\n  local list=\"${1:-today}\"\n\n  case \"$list\" in\n    today)\n      echo \"=== Things 3: Today ===\"\n      osascript -e 'tell application \"Things3\"\n        set output to \"\"\n        repeat with t in to dos of list \"Today\"\n          set taskName to name of t\n          set taskArea to \"\"\n          set taskDue to \"\"\n          try\n            set taskArea to name of area of t\n          end try\n          try\n            set taskDue to due date of t as string\n          end try\n          if taskArea is not \"\" then\n            set output to output & \"[\" & taskArea & \"] \"\n          end if\n          set output to output & taskName\n          if taskDue is not \"\" then\n            set output to output & \" ðŸ“… \" & taskDue\n          end if\n          set output to output & \"\\n\"\n        end repeat\n        return output\n      end tell'\n      ;;\n    anytime)\n      echo \"=== Things 3: Anytime ===\"\n      osascript -e 'tell application \"Things3\"\n        set output to \"\"\n        repeat with t in to dos of list \"Anytime\"\n          set taskName to name of t\n          set taskArea to \"\"\n          try\n            set taskArea to name of area of t\n          end try\n          if taskArea is not \"\" then\n            set output to output & \"[\" & taskArea & \"] \"\n          end if\n          set output to output & taskName & \"\\n\"\n        end repeat\n        return output\n      end tell' | head -30\n      ;;\n    areas)\n      echo \"=== Things 3: Tasks by Area ===\"\n      osascript -e 'tell application \"Things3\"\n        set output to \"\"\n        repeat with a in areas\n          set areaName to name of a\n          set areaTasks to to dos of a\n          if (count of areaTasks) > 0 then\n            set output to output & \"\\n\" & areaName & \":\\n\"\n            repeat with t in areaTasks\n              set taskName to name of t\n              set output to output & \"  - \" & taskName & \"\\n\"\n            end repeat\n          end if\n        end repeat\n        return output\n      end tell'\n      ;;\n    *)\n      echo \"Usage: ./cli.sh things [today|anytime|areas]\"\n      ;;\n  esac\n}\n\ncmd_status() {\n  cd \"$SCRIPT_DIR\"\n\n  echo \"=== Git Status ===\"\n\n  # Branch\n  branch=$(git branch --show-current)\n  echo \"Branch: $branch\"\n\n  # Uncommitted changes\n  changes=$(git status --porcelain | wc -l | tr -d ' ')\n  if [ \"$changes\" -gt 0 ]; then\n    echo \"Uncommitted changes: $changes files\"\n    git status --short\n  else\n    echo \"Working tree clean.\"\n  fi\n\n  # Ahead/behind\n  git fetch origin main --quiet 2>/dev/null || true\n  ahead=$(git rev-list --count origin/main..HEAD 2>/dev/null || echo \"0\")\n  behind=$(git rev-list --count HEAD..origin/main 2>/dev/null || echo \"0\")\n\n  if [ \"$ahead\" -gt 0 ] || [ \"$behind\" -gt 0 ]; then\n    echo \"Ahead: $ahead, Behind: $behind\"\n  fi\n}\n\n# === Main ===\n\ncase \"${1:-}\" in\n  sync)\n    cmd_sync\n    ;;\n  status)\n    cmd_status\n    ;;\n  read)\n    cmd_read \"$2\"\n    ;;\n  tasks)\n    shift\n    cmd_tasks \"$@\"\n    ;;\n  things)\n    shift\n    cmd_things \"$@\"\n    ;;\n  help|--help|-h)\n    echo \"Usage: ./cli.sh <command>\"\n    echo \"\"\n    echo \"Custom commands:\"\n    echo \"  sync              Commit all changes and push to main\"\n    echo \"  status            Show git status summary\"\n    echo \"  read <note>       Read note with backlinks\"\n    echo \"  tasks [path]      List open tasks\"\n    echo \"        --p1/p2/p3  Filter by priority\"\n    echo \"        --next      Filter by #next tag\"\n    echo \"  things [list]     Query Things 3\"\n    echo \"        today       Today list (default)\"\n    echo \"        anytime     Anytime list\"\n    echo \"        areas       Tasks grouped by area\"\n    echo \"\"\n    echo \"Obsidian commands:\"\n    ensure_binary\n    \"$CLI_DIR/obsidian-cli\" --help\n    ;;\n  *)\n    ensure_binary\n    exec \"$CLI_DIR/obsidian-cli\" \"$@\"\n    ;;\nesac\n",
      "newContent": "#!/bin/bash\n# cli.sh - Bootstrap script for obsidian-cli + custom commands\n# Downloads the appropriate binary on first run\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"$0\")\" && pwd)\"\nCLI_DIR=\"$SCRIPT_DIR/.cli\"\nVERSION=\"0.2.0\"\nGITHUB_RELEASE=\"https://github.com/Yakitrak/obsidian-cli/releases/download/v${VERSION}\"\n\ndetect_platform() {\n  case \"$(uname -s)\" in\n    Darwin*)\n      echo \"darwin_all\"\n      ;;\n    Linux*)\n      case \"$(uname -m)\" in\n        x86_64)  echo \"linux_amd64\" ;;\n        aarch64|arm64) echo \"linux_arm64\" ;;\n        *) echo \"Unsupported architecture: $(uname -m)\" >&2; exit 1 ;;\n      esac\n      ;;\n    *)\n      echo \"Unsupported OS: $(uname -s)\" >&2\n      exit 1\n      ;;\n  esac\n}\n\nensure_binary() {\n  local platform=$(detect_platform)\n  local binary=\"$CLI_DIR/obsidian-cli\"\n  local tarball=\"obsidian-cli_${VERSION}_${platform}.tar.gz\"\n  local url=\"$GITHUB_RELEASE/$tarball\"\n\n  if [ ! -x \"$binary\" ]; then\n    echo \"Downloading obsidian-cli v${VERSION} for ${platform}...\" >&2\n    mkdir -p \"$CLI_DIR\"\n\n    if command -v curl &> /dev/null; then\n      curl -fsSL \"$url\" | tar -xz -C \"$CLI_DIR\"\n    elif command -v wget &> /dev/null; then\n      wget -qO- \"$url\" | tar -xz -C \"$CLI_DIR\"\n    else\n      echo \"Error: curl or wget required\" >&2\n      exit 1\n    fi\n\n    chmod +x \"$binary\"\n    echo \"Installed to $CLI_DIR\" >&2\n  fi\n}\n\n# === Git Remote Handling ===\n\n# Extract GitHub repo from current remote (handles various URL formats)\nget_github_repo() {\n  local remote=$(git remote get-url origin 2>/dev/null || echo \"\")\n  local repo=\"\"\n\n  # Extract owner/repo from various formats:\n  # - https://github.com/owner/repo.git\n  # - git@github.com:owner/repo.git\n  # - http://proxy@127.0.0.1:PORT/git/owner/repo\n\n  if echo \"$remote\" | grep -q \"github.com\"; then\n    repo=$(echo \"$remote\" | sed -E 's|.*github\\.com[:/]||' | sed 's|\\.git$||')\n  elif echo \"$remote\" | grep -q \"/git/\"; then\n    repo=$(echo \"$remote\" | sed -E 's|.*/git/||')\n  fi\n\n  echo \"$repo\"\n}\n\n# Ensure remote origin points directly to GitHub (not through proxy)\nensure_remote() {\n  local current_remote=$(git remote get-url origin 2>/dev/null || echo \"\")\n  local repo=$(get_github_repo)\n\n  if [ -z \"$repo\" ]; then\n    echo \"ERROR: Could not determine GitHub repo from remote\" >&2\n    echo \"Current remote: $current_remote\" >&2\n    exit 1\n  fi\n\n  # Check if remote is already correct (github.com, not proxy)\n  if echo \"$current_remote\" | grep -q \"github.com\"; then\n    return 0\n  fi\n\n  # Need to fix remote - check for GH_TOKEN\n  if [ -z \"$GH_TOKEN\" ]; then\n    echo \"ERROR: Remote needs fixing but GH_TOKEN is not set\" >&2\n    echo \"Current remote: $current_remote\" >&2\n    echo \"\" >&2\n    echo \"To fix: set GH_TOKEN environment variable with your GitHub token\" >&2\n    exit 1\n  fi\n\n  local auth_remote=\"https://x-access-token:${GH_TOKEN}@github.com/${repo}.git\"\n\n  echo \"Fixing remote origin...\"\n  echo \"  Was: $current_remote\"\n  echo \"  Now: https://***@github.com/${repo}.git\"\n\n  git remote set-url origin \"$auth_remote\"\n}\n\n# Ensure main branch exists locally\nensure_main_branch() {\n  # Check if main exists locally\n  if git show-ref --verify --quiet refs/heads/main; then\n    return 0\n  fi\n\n  echo \"Branch 'main' not found locally. Fetching...\"\n\n  # Try to fetch main from origin\n  if git fetch origin main:main 2>/dev/null; then\n    echo \"Fetched 'main' from origin.\"\n  else\n    # Maybe we need to create it from current HEAD\n    echo \"Creating 'main' branch from current HEAD...\"\n    git branch main\n  fi\n}\n\ncmd_sync() {\n  cd \"$SCRIPT_DIR\"\n\n  # Ensure remote is configured correctly\n  ensure_remote\n\n  # Ensure main branch exists\n  ensure_main_branch\n\n  # Check current branch\n  current_branch=$(git branch --show-current)\n\n  # Switch to main if needed\n  if [ \"$current_branch\" != \"main\" ]; then\n    echo \"Switching from '$current_branch' to 'main'...\"\n    git checkout main\n  fi\n\n  # Check for uncommitted changes\n  if git diff --quiet && git diff --staged --quiet; then\n    # Check for untracked files\n    if [ -z \"$(git ls-files --others --exclude-standard)\" ]; then\n      echo \"Nothing to sync.\"\n      exit 0\n    fi\n  fi\n\n  # Stage all changes\n  git add -A\n\n  # Commit with timestamp\n  timestamp=$(date '+%Y-%m-%d %H:%M')\n  git commit -m \"sync: $timestamp\"\n\n  echo \"Committed. Pushing to main...\"\n\n  # Try to push\n  if git push origin main 2>&1; then\n    echo \"Synced successfully.\"\n  else\n    echo \"\"\n    echo \"=== PUSH FAILED ===\"\n    echo \"Conflict detected. Pulling with rebase...\"\n    echo \"\"\n\n    # Try to pull and rebase\n    if git pull --rebase origin main 2>&1; then\n      echo \"Rebase successful. Pushing again...\"\n      if git push origin main 2>&1; then\n        echo \"Synced successfully after rebase.\"\n      else\n        echo \"\"\n        echo \"=== CRITICAL: Push still failing ===\"\n        echo \"Manual intervention required. Current status:\"\n        git status\n        exit 1\n      fi\n    else\n      echo \"\"\n      echo \"=== CRITICAL: Rebase conflict ===\"\n      echo \"Manual intervention required.\"\n      echo \"\"\n      echo \"Conflicting files:\"\n      git diff --name-only --diff-filter=U\n      echo \"\"\n      echo \"To resolve:\"\n      echo \"1. Edit conflicting files\"\n      echo \"2. git add <resolved files>\"\n      echo \"3. git rebase --continue\"\n      echo \"4. ./cli.sh sync\"\n      exit 1\n    fi\n  fi\n}\n\ncmd_read() {\n  cd \"$SCRIPT_DIR\"\n  local query=\"$1\"\n\n  if [ -z \"$query\" ]; then\n    echo \"Usage: ./cli.sh read <note-name or path>\" >&2\n    exit 1\n  fi\n\n  # Find the file\n  local file=\"\"\n\n  # If it's a direct path that exists\n  if [ -f \"$query\" ]; then\n    file=\"$query\"\n  elif [ -f \"$query.md\" ]; then\n    file=\"$query.md\"\n  else\n    # Search for Obsidian-style note name\n    file=$(find . -name \"*.md\" -type f | grep -i \"$query\" | head -1)\n  fi\n\n  if [ -z \"$file\" ] || [ ! -f \"$file\" ]; then\n    echo \"Note not found: $query\" >&2\n    exit 1\n  fi\n\n  # Get the basename for backlink search\n  local basename=$(basename \"$file\" .md)\n\n  # Print file content with line numbers (same format as Claude Read tool)\n  local abs_path=\"$(cd \"$(dirname \"$file\")\" && pwd)/$(basename \"$file\")\"\n  echo \"=== $abs_path ===\"\n  echo \"\"\n  awk '{printf \"%6dâ†’%s\\n\", NR, $0}' \"$file\"\n\n  # Find and print backlinks\n  echo \"\"\n  echo \"=== Backlinks ===\"\n\n  local backlinks=$(grep -rn \"\\[\\[$basename\" --include=\"*.md\" . 2>/dev/null | grep -v \"^$file:\" || true)\n\n  if [ -n \"$backlinks\" ]; then\n    echo \"$backlinks\"\n  else\n    echo \"(no backlinks)\"\n  fi\n}\n\ncmd_tasks() {\n  cd \"$SCRIPT_DIR\"\n\n  local path_filter=\"\"\n  local tag_filter=\"\"\n  local show_all=false\n\n  # Parse arguments\n  while [[ $# -gt 0 ]]; do\n    case \"$1\" in\n      --p1|--p2|--p3)\n        tag_filter=\"${1#--}\"\n        shift\n        ;;\n      --next|--waiting|--someday)\n        tag_filter=\"${1#--}\"\n        shift\n        ;;\n      --all)\n        show_all=true\n        shift\n        ;;\n      -*)\n        echo \"Unknown option: $1\" >&2\n        echo \"Usage: ./cli.sh tasks [path] [--p1|--p2|--p3|--next|--waiting|--someday] [--all]\" >&2\n        exit 1\n        ;;\n      *)\n        path_filter=\"$1\"\n        shift\n        ;;\n    esac\n  done\n\n  # Build search path\n  local search_path=\".\"\n  if [ -n \"$path_filter\" ]; then\n    # Find directories matching the filter\n    search_path=$(find . -type d -iname \"*$path_filter*\" 2>/dev/null | head -1)\n    if [ -z \"$search_path\" ]; then\n      # Try as a direct path\n      if [ -d \"$path_filter\" ]; then\n        search_path=\"$path_filter\"\n      else\n        echo \"No directory matching: $path_filter\" >&2\n        exit 1\n      fi\n    fi\n  fi\n\n  echo \"=== Tasks in $search_path ===\"\n  echo \"\"\n\n  # Find all unchecked tasks\n  local tasks\n  tasks=$(grep -rn \"\\- \\[ \\]\" --include=\"*.md\" \"$search_path\" 2>/dev/null || true)\n\n  if [ -z \"$tasks\" ]; then\n    echo \"No open tasks found.\"\n    return 0\n  fi\n\n  # Filter by tag if specified\n  if [ -n \"$tag_filter\" ]; then\n    tasks=$(echo \"$tasks\" | grep -i \"#$tag_filter\" || true)\n    if [ -z \"$tasks\" ]; then\n      echo \"No tasks with #$tag_filter\"\n      return 0\n    fi\n    echo \"Filtered by: #$tag_filter\"\n    echo \"\"\n  fi\n\n  # Group and display\n  local current_file=\"\"\n  local count=0\n\n  echo \"$tasks\" | while IFS= read -r line; do\n    # Extract file path and line number\n    local file=$(echo \"$line\" | cut -d: -f1)\n    local linenum=$(echo \"$line\" | cut -d: -f2)\n    local content=$(echo \"$line\" | cut -d: -f3-)\n\n    # Clean up content - remove leading spaces and the checkbox\n    content=$(echo \"$content\" | sed 's/^[[:space:]]*- \\[ \\] //')\n\n    # Print file header if new file\n    if [ \"$file\" != \"$current_file\" ]; then\n      if [ -n \"$current_file\" ]; then\n        echo \"\"\n      fi\n      echo \"$file\"\n      current_file=\"$file\"\n    fi\n\n    # Highlight priority tags\n    if echo \"$content\" | grep -q \"#p1\"; then\n      echo \"  [!] $content\"\n    elif echo \"$content\" | grep -q \"#p2\"; then\n      echo \"  [*] $content\"\n    elif echo \"$content\" | grep -q \"#p3\"; then\n      echo \"  [-] $content\"\n    elif echo \"$content\" | grep -q \"#next\"; then\n      echo \"  [>] $content\"\n    elif echo \"$content\" | grep -q \"#waiting\"; then\n      echo \"  [?] $content\"\n    elif echo \"$content\" | grep -q \"#someday\"; then\n      echo \"  [~] $content\"\n    else\n      echo \"  [ ] $content\"\n    fi\n\n    count=$((count + 1))\n  done\n\n  echo \"\"\n  echo \"---\"\n  local total=$(echo \"$tasks\" | wc -l | tr -d ' ')\n  echo \"Total: $total tasks\"\n}\n\ncmd_daily() {\n  cd \"$SCRIPT_DIR\"\n\n  # Get current date\n  local year=$(date '+%Y')\n  local month=$(date '+%m')\n  local date_str=$(date '+%Y-%m-%d')\n\n  # Ensure directory exists\n  local daily_dir=\"Daily/$year/$month\"\n  mkdir -p \"$daily_dir\"\n\n  # Ensure Briefs subfolder exists\n  mkdir -p \"$daily_dir/Briefs\"\n\n  # Create the daily note file\n  local daily_file=\"$daily_dir/$date_str.md\"\n\n  # Check if file already exists\n  if [ -f \"$daily_file\" ]; then\n    echo \"Daily note already exists: $daily_file\"\n  else\n    # Copy template if it exists\n    if [ -f \"Templates/Daily.md\" ]; then\n      cp \"Templates/Daily.md\" \"$daily_file\"\n      echo \"Created daily note: $daily_file\"\n    else\n      # Create basic template if none exists\n      cat > \"$daily_file\" << EOF\n# $date_str\n\n## ðŸŽ¯ #1 Priority\n\n## Workspace\n\n### Deep Work\n\n### Capture\n\n## Logbook\n\nEOF\n      echo \"Created daily note: $daily_file\"\n    fi\n  fi\n\n  # Open in Obsidian\n  \"$CLI_DIR/obsidian-cli\" open \"$daily_file\"\n}\n\ncmd_things() {\n  local list=\"${1:-today}\"\n\n  case \"$list\" in\n    today)\n      echo \"=== Things 3: Today ===\"\n      osascript -e 'tell application \"Things3\"\n        set output to \"\"\n        repeat with t in to dos of list \"Today\"\n          set taskName to name of t\n          set taskArea to \"\"\n          set taskDue to \"\"\n          try\n            set taskArea to name of area of t\n          end try\n          try\n            set taskDue to due date of t as string\n          end try\n          if taskArea is not \"\" then\n            set output to output & \"[\" & taskArea & \"] \"\n          end if\n          set output to output & taskName\n          if taskDue is not \"\" then\n            set output to output & \" ðŸ“… \" & taskDue\n          end if\n          set output to output & \"\\n\"\n        end repeat\n        return output\n      end tell'\n      ;;\n    anytime)\n      echo \"=== Things 3: Anytime ===\"\n      osascript -e 'tell application \"Things3\"\n        set output to \"\"\n        repeat with t in to dos of list \"Anytime\"\n          set taskName to name of t\n          set taskArea to \"\"\n          try\n            set taskArea to name of area of t\n          end try\n          if taskArea is not \"\" then\n            set output to output & \"[\" & taskArea & \"] \"\n          end if\n          set output to output & taskName & \"\\n\"\n        end repeat\n        return output\n      end tell' | head -30\n      ;;\n    areas)\n      echo \"=== Things 3: Tasks by Area ===\"\n      osascript -e 'tell application \"Things3\"\n        set output to \"\"\n        repeat with a in areas\n          set areaName to name of a\n          set areaTasks to to dos of a\n          if (count of areaTasks) > 0 then\n            set output to output & \"\\n\" & areaName & \":\\n\"\n            repeat with t in areaTasks\n              set taskName to name of t\n              set output to output & \"  - \" & taskName & \"\\n\"\n            end repeat\n          end if\n        end repeat\n        return output\n      end tell'\n      ;;\n    *)\n      echo \"Usage: ./cli.sh things [today|anytime|areas]\"\n      ;;\n  esac\n}\n\ncmd_status() {\n  cd \"$SCRIPT_DIR\"\n\n  echo \"=== Git Status ===\"\n\n  # Branch\n  branch=$(git branch --show-current)\n  echo \"Branch: $branch\"\n\n  # Uncommitted changes\n  changes=$(git status --porcelain | wc -l | tr -d ' ')\n  if [ \"$changes\" -gt 0 ]; then\n    echo \"Uncommitted changes: $changes files\"\n    git status --short\n  else\n    echo \"Working tree clean.\"\n  fi\n\n  # Ahead/behind\n  git fetch origin main --quiet 2>/dev/null || true\n  ahead=$(git rev-list --count origin/main..HEAD 2>/dev/null || echo \"0\")\n  behind=$(git rev-list --count HEAD..origin/main 2>/dev/null || echo \"0\")\n\n  if [ \"$ahead\" -gt 0 ] || [ \"$behind\" -gt 0 ]; then\n    echo \"Ahead: $ahead, Behind: $behind\"\n  fi\n}\n\n# === Main ===\n\ncase \"${1:-}\" in\n  sync)\n    cmd_sync\n    ;;\n  status)\n    cmd_status\n    ;;\n  read)\n    cmd_read \"$2\"\n    ;;\n  daily)\n    cmd_daily\n    ;;\n  tasks)\n    shift\n    cmd_tasks \"$@\"\n    ;;\n  things)\n    shift\n    cmd_things \"$@\"\n    ;;\n  help|--help|-h)\n    echo \"Usage: ./cli.sh <command>\"\n    echo \"\"\n    echo \"Custom commands:\"\n    echo \"  sync              Commit all changes and push to main\"\n    echo \"  status            Show git status summary\"\n    echo \"  read <note>       Read note with backlinks\"\n    echo \"  tasks [path]      List open tasks\"\n    echo \"        --p1/p2/p3  Filter by priority\"\n    echo \"        --next      Filter by #next tag\"\n    echo \"  things [list]     Query Things 3\"\n    echo \"        today       Today list (default)\"\n    echo \"        anytime     Anytime list\"\n    echo \"        areas       Tasks grouped by area\"\n    echo \"\"\n    echo \"Obsidian commands:\"\n    ensure_binary\n    \"$CLI_DIR/obsidian-cli\" --help\n    ;;\n  *)\n    ensure_binary\n    exec \"$CLI_DIR/obsidian-cli\" \"$@\"\n    ;;\nesac\n"
    },
    "toolu_0172KA7PghY9tGyccoHox5cX": {
      "filePath": "cli.sh",
      "originalContent": "#!/bin/bash\n# cli.sh - Bootstrap script for obsidian-cli + custom commands\n# Downloads the appropriate binary on first run\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"$0\")\" && pwd)\"\nCLI_DIR=\"$SCRIPT_DIR/.cli\"\nVERSION=\"0.2.0\"\nGITHUB_RELEASE=\"https://github.com/Yakitrak/obsidian-cli/releases/download/v${VERSION}\"\n\ndetect_platform() {\n  case \"$(uname -s)\" in\n    Darwin*)\n      echo \"darwin_all\"\n      ;;\n    Linux*)\n      case \"$(uname -m)\" in\n        x86_64)  echo \"linux_amd64\" ;;\n        aarch64|arm64) echo \"linux_arm64\" ;;\n        *) echo \"Unsupported architecture: $(uname -m)\" >&2; exit 1 ;;\n      esac\n      ;;\n    *)\n      echo \"Unsupported OS: $(uname -s)\" >&2\n      exit 1\n      ;;\n  esac\n}\n\nensure_binary() {\n  local platform=$(detect_platform)\n  local binary=\"$CLI_DIR/obsidian-cli\"\n  local tarball=\"obsidian-cli_${VERSION}_${platform}.tar.gz\"\n  local url=\"$GITHUB_RELEASE/$tarball\"\n\n  if [ ! -x \"$binary\" ]; then\n    echo \"Downloading obsidian-cli v${VERSION} for ${platform}...\" >&2\n    mkdir -p \"$CLI_DIR\"\n\n    if command -v curl &> /dev/null; then\n      curl -fsSL \"$url\" | tar -xz -C \"$CLI_DIR\"\n    elif command -v wget &> /dev/null; then\n      wget -qO- \"$url\" | tar -xz -C \"$CLI_DIR\"\n    else\n      echo \"Error: curl or wget required\" >&2\n      exit 1\n    fi\n\n    chmod +x \"$binary\"\n    echo \"Installed to $CLI_DIR\" >&2\n  fi\n}\n\n# === Git Remote Handling ===\n\n# Extract GitHub repo from current remote (handles various URL formats)\nget_github_repo() {\n  local remote=$(git remote get-url origin 2>/dev/null || echo \"\")\n  local repo=\"\"\n\n  # Extract owner/repo from various formats:\n  # - https://github.com/owner/repo.git\n  # - git@github.com:owner/repo.git\n  # - http://proxy@127.0.0.1:PORT/git/owner/repo\n\n  if echo \"$remote\" | grep -q \"github.com\"; then\n    repo=$(echo \"$remote\" | sed -E 's|.*github\\.com[:/]||' | sed 's|\\.git$||')\n  elif echo \"$remote\" | grep -q \"/git/\"; then\n    repo=$(echo \"$remote\" | sed -E 's|.*/git/||')\n  fi\n\n  echo \"$repo\"\n}\n\n# Ensure remote origin points directly to GitHub (not through proxy)\nensure_remote() {\n  local current_remote=$(git remote get-url origin 2>/dev/null || echo \"\")\n  local repo=$(get_github_repo)\n\n  if [ -z \"$repo\" ]; then\n    echo \"ERROR: Could not determine GitHub repo from remote\" >&2\n    echo \"Current remote: $current_remote\" >&2\n    exit 1\n  fi\n\n  # Check if remote is already correct (github.com, not proxy)\n  if echo \"$current_remote\" | grep -q \"github.com\"; then\n    return 0\n  fi\n\n  # Need to fix remote - check for GH_TOKEN\n  if [ -z \"$GH_TOKEN\" ]; then\n    echo \"ERROR: Remote needs fixing but GH_TOKEN is not set\" >&2\n    echo \"Current remote: $current_remote\" >&2\n    echo \"\" >&2\n    echo \"To fix: set GH_TOKEN environment variable with your GitHub token\" >&2\n    exit 1\n  fi\n\n  local auth_remote=\"https://x-access-token:${GH_TOKEN}@github.com/${repo}.git\"\n\n  echo \"Fixing remote origin...\"\n  echo \"  Was: $current_remote\"\n  echo \"  Now: https://***@github.com/${repo}.git\"\n\n  git remote set-url origin \"$auth_remote\"\n}\n\n# Ensure main branch exists locally\nensure_main_branch() {\n  # Check if main exists locally\n  if git show-ref --verify --quiet refs/heads/main; then\n    return 0\n  fi\n\n  echo \"Branch 'main' not found locally. Fetching...\"\n\n  # Try to fetch main from origin\n  if git fetch origin main:main 2>/dev/null; then\n    echo \"Fetched 'main' from origin.\"\n  else\n    # Maybe we need to create it from current HEAD\n    echo \"Creating 'main' branch from current HEAD...\"\n    git branch main\n  fi\n}\n\ncmd_sync() {\n  cd \"$SCRIPT_DIR\"\n\n  # Ensure remote is configured correctly\n  ensure_remote\n\n  # Ensure main branch exists\n  ensure_main_branch\n\n  # Check current branch\n  current_branch=$(git branch --show-current)\n\n  # Switch to main if needed\n  if [ \"$current_branch\" != \"main\" ]; then\n    echo \"Switching from '$current_branch' to 'main'...\"\n    git checkout main\n  fi\n\n  # Check for uncommitted changes\n  if git diff --quiet && git diff --staged --quiet; then\n    # Check for untracked files\n    if [ -z \"$(git ls-files --others --exclude-standard)\" ]; then\n      echo \"Nothing to sync.\"\n      exit 0\n    fi\n  fi\n\n  # Stage all changes\n  git add -A\n\n  # Commit with timestamp\n  timestamp=$(date '+%Y-%m-%d %H:%M')\n  git commit -m \"sync: $timestamp\"\n\n  echo \"Committed. Pushing to main...\"\n\n  # Try to push\n  if git push origin main 2>&1; then\n    echo \"Synced successfully.\"\n  else\n    echo \"\"\n    echo \"=== PUSH FAILED ===\"\n    echo \"Conflict detected. Pulling with rebase...\"\n    echo \"\"\n\n    # Try to pull and rebase\n    if git pull --rebase origin main 2>&1; then\n      echo \"Rebase successful. Pushing again...\"\n      if git push origin main 2>&1; then\n        echo \"Synced successfully after rebase.\"\n      else\n        echo \"\"\n        echo \"=== CRITICAL: Push still failing ===\"\n        echo \"Manual intervention required. Current status:\"\n        git status\n        exit 1\n      fi\n    else\n      echo \"\"\n      echo \"=== CRITICAL: Rebase conflict ===\"\n      echo \"Manual intervention required.\"\n      echo \"\"\n      echo \"Conflicting files:\"\n      git diff --name-only --diff-filter=U\n      echo \"\"\n      echo \"To resolve:\"\n      echo \"1. Edit conflicting files\"\n      echo \"2. git add <resolved files>\"\n      echo \"3. git rebase --continue\"\n      echo \"4. ./cli.sh sync\"\n      exit 1\n    fi\n  fi\n}\n\ncmd_read() {\n  cd \"$SCRIPT_DIR\"\n  local query=\"$1\"\n\n  if [ -z \"$query\" ]; then\n    echo \"Usage: ./cli.sh read <note-name or path>\" >&2\n    exit 1\n  fi\n\n  # Find the file\n  local file=\"\"\n\n  # If it's a direct path that exists\n  if [ -f \"$query\" ]; then\n    file=\"$query\"\n  elif [ -f \"$query.md\" ]; then\n    file=\"$query.md\"\n  else\n    # Search for Obsidian-style note name\n    file=$(find . -name \"*.md\" -type f | grep -i \"$query\" | head -1)\n  fi\n\n  if [ -z \"$file\" ] || [ ! -f \"$file\" ]; then\n    echo \"Note not found: $query\" >&2\n    exit 1\n  fi\n\n  # Get the basename for backlink search\n  local basename=$(basename \"$file\" .md)\n\n  # Print file content with line numbers (same format as Claude Read tool)\n  local abs_path=\"$(cd \"$(dirname \"$file\")\" && pwd)/$(basename \"$file\")\"\n  echo \"=== $abs_path ===\"\n  echo \"\"\n  awk '{printf \"%6dâ†’%s\\n\", NR, $0}' \"$file\"\n\n  # Find and print backlinks\n  echo \"\"\n  echo \"=== Backlinks ===\"\n\n  local backlinks=$(grep -rn \"\\[\\[$basename\" --include=\"*.md\" . 2>/dev/null | grep -v \"^$file:\" || true)\n\n  if [ -n \"$backlinks\" ]; then\n    echo \"$backlinks\"\n  else\n    echo \"(no backlinks)\"\n  fi\n}\n\ncmd_tasks() {\n  cd \"$SCRIPT_DIR\"\n\n  local path_filter=\"\"\n  local tag_filter=\"\"\n  local show_all=false\n\n  # Parse arguments\n  while [[ $# -gt 0 ]]; do\n    case \"$1\" in\n      --p1|--p2|--p3)\n        tag_filter=\"${1#--}\"\n        shift\n        ;;\n      --next|--waiting|--someday)\n        tag_filter=\"${1#--}\"\n        shift\n        ;;\n      --all)\n        show_all=true\n        shift\n        ;;\n      -*)\n        echo \"Unknown option: $1\" >&2\n        echo \"Usage: ./cli.sh tasks [path] [--p1|--p2|--p3|--next|--waiting|--someday] [--all]\" >&2\n        exit 1\n        ;;\n      *)\n        path_filter=\"$1\"\n        shift\n        ;;\n    esac\n  done\n\n  # Build search path\n  local search_path=\".\"\n  if [ -n \"$path_filter\" ]; then\n    # Find directories matching the filter\n    search_path=$(find . -type d -iname \"*$path_filter*\" 2>/dev/null | head -1)\n    if [ -z \"$search_path\" ]; then\n      # Try as a direct path\n      if [ -d \"$path_filter\" ]; then\n        search_path=\"$path_filter\"\n      else\n        echo \"No directory matching: $path_filter\" >&2\n        exit 1\n      fi\n    fi\n  fi\n\n  echo \"=== Tasks in $search_path ===\"\n  echo \"\"\n\n  # Find all unchecked tasks\n  local tasks\n  tasks=$(grep -rn \"\\- \\[ \\]\" --include=\"*.md\" \"$search_path\" 2>/dev/null || true)\n\n  if [ -z \"$tasks\" ]; then\n    echo \"No open tasks found.\"\n    return 0\n  fi\n\n  # Filter by tag if specified\n  if [ -n \"$tag_filter\" ]; then\n    tasks=$(echo \"$tasks\" | grep -i \"#$tag_filter\" || true)\n    if [ -z \"$tasks\" ]; then\n      echo \"No tasks with #$tag_filter\"\n      return 0\n    fi\n    echo \"Filtered by: #$tag_filter\"\n    echo \"\"\n  fi\n\n  # Group and display\n  local current_file=\"\"\n  local count=0\n\n  echo \"$tasks\" | while IFS= read -r line; do\n    # Extract file path and line number\n    local file=$(echo \"$line\" | cut -d: -f1)\n    local linenum=$(echo \"$line\" | cut -d: -f2)\n    local content=$(echo \"$line\" | cut -d: -f3-)\n\n    # Clean up content - remove leading spaces and the checkbox\n    content=$(echo \"$content\" | sed 's/^[[:space:]]*- \\[ \\] //')\n\n    # Print file header if new file\n    if [ \"$file\" != \"$current_file\" ]; then\n      if [ -n \"$current_file\" ]; then\n        echo \"\"\n      fi\n      echo \"$file\"\n      current_file=\"$file\"\n    fi\n\n    # Highlight priority tags\n    if echo \"$content\" | grep -q \"#p1\"; then\n      echo \"  [!] $content\"\n    elif echo \"$content\" | grep -q \"#p2\"; then\n      echo \"  [*] $content\"\n    elif echo \"$content\" | grep -q \"#p3\"; then\n      echo \"  [-] $content\"\n    elif echo \"$content\" | grep -q \"#next\"; then\n      echo \"  [>] $content\"\n    elif echo \"$content\" | grep -q \"#waiting\"; then\n      echo \"  [?] $content\"\n    elif echo \"$content\" | grep -q \"#someday\"; then\n      echo \"  [~] $content\"\n    else\n      echo \"  [ ] $content\"\n    fi\n\n    count=$((count + 1))\n  done\n\n  echo \"\"\n  echo \"---\"\n  local total=$(echo \"$tasks\" | wc -l | tr -d ' ')\n  echo \"Total: $total tasks\"\n}\n\ncmd_daily() {\n  cd \"$SCRIPT_DIR\"\n\n  # Get current date\n  local year=$(date '+%Y')\n  local month=$(date '+%m')\n  local date_str=$(date '+%Y-%m-%d')\n\n  # Ensure directory exists\n  local daily_dir=\"Daily/$year/$month\"\n  mkdir -p \"$daily_dir\"\n\n  # Ensure Briefs subfolder exists\n  mkdir -p \"$daily_dir/Briefs\"\n\n  # Create the daily note file\n  local daily_file=\"$daily_dir/$date_str.md\"\n\n  # Check if file already exists\n  if [ -f \"$daily_file\" ]; then\n    echo \"Daily note already exists: $daily_file\"\n  else\n    # Copy template if it exists\n    if [ -f \"Templates/Daily.md\" ]; then\n      cp \"Templates/Daily.md\" \"$daily_file\"\n      echo \"Created daily note: $daily_file\"\n    else\n      # Create basic template if none exists\n      cat > \"$daily_file\" << EOF\n# $date_str\n\n## ðŸŽ¯ #1 Priority\n\n## Workspace\n\n### Deep Work\n\n### Capture\n\n## Logbook\n\nEOF\n      echo \"Created daily note: $daily_file\"\n    fi\n  fi\n\n  # Open in Obsidian\n  \"$CLI_DIR/obsidian-cli\" open \"$daily_file\"\n}\n\ncmd_things() {\n  local list=\"${1:-today}\"\n\n  case \"$list\" in\n    today)\n      echo \"=== Things 3: Today ===\"\n      osascript -e 'tell application \"Things3\"\n        set output to \"\"\n        repeat with t in to dos of list \"Today\"\n          set taskName to name of t\n          set taskArea to \"\"\n          set taskDue to \"\"\n          try\n            set taskArea to name of area of t\n          end try\n          try\n            set taskDue to due date of t as string\n          end try\n          if taskArea is not \"\" then\n            set output to output & \"[\" & taskArea & \"] \"\n          end if\n          set output to output & taskName\n          if taskDue is not \"\" then\n            set output to output & \" ðŸ“… \" & taskDue\n          end if\n          set output to output & \"\\n\"\n        end repeat\n        return output\n      end tell'\n      ;;\n    anytime)\n      echo \"=== Things 3: Anytime ===\"\n      osascript -e 'tell application \"Things3\"\n        set output to \"\"\n        repeat with t in to dos of list \"Anytime\"\n          set taskName to name of t\n          set taskArea to \"\"\n          try\n            set taskArea to name of area of t\n          end try\n          if taskArea is not \"\" then\n            set output to output & \"[\" & taskArea & \"] \"\n          end if\n          set output to output & taskName & \"\\n\"\n        end repeat\n        return output\n      end tell' | head -30\n      ;;\n    areas)\n      echo \"=== Things 3: Tasks by Area ===\"\n      osascript -e 'tell application \"Things3\"\n        set output to \"\"\n        repeat with a in areas\n          set areaName to name of a\n          set areaTasks to to dos of a\n          if (count of areaTasks) > 0 then\n            set output to output & \"\\n\" & areaName & \":\\n\"\n            repeat with t in areaTasks\n              set taskName to name of t\n              set output to output & \"  - \" & taskName & \"\\n\"\n            end repeat\n          end if\n        end repeat\n        return output\n      end tell'\n      ;;\n    *)\n      echo \"Usage: ./cli.sh things [today|anytime|areas]\"\n      ;;\n  esac\n}\n\ncmd_status() {\n  cd \"$SCRIPT_DIR\"\n\n  echo \"=== Git Status ===\"\n\n  # Branch\n  branch=$(git branch --show-current)\n  echo \"Branch: $branch\"\n\n  # Uncommitted changes\n  changes=$(git status --porcelain | wc -l | tr -d ' ')\n  if [ \"$changes\" -gt 0 ]; then\n    echo \"Uncommitted changes: $changes files\"\n    git status --short\n  else\n    echo \"Working tree clean.\"\n  fi\n\n  # Ahead/behind\n  git fetch origin main --quiet 2>/dev/null || true\n  ahead=$(git rev-list --count origin/main..HEAD 2>/dev/null || echo \"0\")\n  behind=$(git rev-list --count HEAD..origin/main 2>/dev/null || echo \"0\")\n\n  if [ \"$ahead\" -gt 0 ] || [ \"$behind\" -gt 0 ]; then\n    echo \"Ahead: $ahead, Behind: $behind\"\n  fi\n}\n\n# === Main ===\n\ncase \"${1:-}\" in\n  sync)\n    cmd_sync\n    ;;\n  status)\n    cmd_status\n    ;;\n  read)\n    cmd_read \"$2\"\n    ;;\n  daily)\n    cmd_daily\n    ;;\n  tasks)\n    shift\n    cmd_tasks \"$@\"\n    ;;\n  things)\n    shift\n    cmd_things \"$@\"\n    ;;\n  help|--help|-h)\n    echo \"Usage: ./cli.sh <command>\"\n    echo \"\"\n    echo \"Custom commands:\"\n    echo \"  sync              Commit all changes and push to main\"\n    echo \"  status            Show git status summary\"\n    echo \"  read <note>       Read note with backlinks\"\n    echo \"  tasks [path]      List open tasks\"\n    echo \"        --p1/p2/p3  Filter by priority\"\n    echo \"        --next      Filter by #next tag\"\n    echo \"  things [list]     Query Things 3\"\n    echo \"        today       Today list (default)\"\n    echo \"        anytime     Anytime list\"\n    echo \"        areas       Tasks grouped by area\"\n    echo \"\"\n    echo \"Obsidian commands:\"\n    ensure_binary\n    \"$CLI_DIR/obsidian-cli\" --help\n    ;;\n  *)\n    ensure_binary\n    exec \"$CLI_DIR/obsidian-cli\" \"$@\"\n    ;;\nesac\n",
      "newContent": "#!/bin/bash\n# cli.sh - Bootstrap script for obsidian-cli + custom commands\n# Downloads the appropriate binary on first run\n\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"$0\")\" && pwd)\"\nCLI_DIR=\"$SCRIPT_DIR/.cli\"\nVERSION=\"0.2.0\"\nGITHUB_RELEASE=\"https://github.com/Yakitrak/obsidian-cli/releases/download/v${VERSION}\"\n\ndetect_platform() {\n  case \"$(uname -s)\" in\n    Darwin*)\n      echo \"darwin_all\"\n      ;;\n    Linux*)\n      case \"$(uname -m)\" in\n        x86_64)  echo \"linux_amd64\" ;;\n        aarch64|arm64) echo \"linux_arm64\" ;;\n        *) echo \"Unsupported architecture: $(uname -m)\" >&2; exit 1 ;;\n      esac\n      ;;\n    *)\n      echo \"Unsupported OS: $(uname -s)\" >&2\n      exit 1\n      ;;\n  esac\n}\n\nensure_binary() {\n  local platform=$(detect_platform)\n  local binary=\"$CLI_DIR/obsidian-cli\"\n  local tarball=\"obsidian-cli_${VERSION}_${platform}.tar.gz\"\n  local url=\"$GITHUB_RELEASE/$tarball\"\n\n  if [ ! -x \"$binary\" ]; then\n    echo \"Downloading obsidian-cli v${VERSION} for ${platform}...\" >&2\n    mkdir -p \"$CLI_DIR\"\n\n    if command -v curl &> /dev/null; then\n      curl -fsSL \"$url\" | tar -xz -C \"$CLI_DIR\"\n    elif command -v wget &> /dev/null; then\n      wget -qO- \"$url\" | tar -xz -C \"$CLI_DIR\"\n    else\n      echo \"Error: curl or wget required\" >&2\n      exit 1\n    fi\n\n    chmod +x \"$binary\"\n    echo \"Installed to $CLI_DIR\" >&2\n  fi\n}\n\n# === Git Remote Handling ===\n\n# Extract GitHub repo from current remote (handles various URL formats)\nget_github_repo() {\n  local remote=$(git remote get-url origin 2>/dev/null || echo \"\")\n  local repo=\"\"\n\n  # Extract owner/repo from various formats:\n  # - https://github.com/owner/repo.git\n  # - git@github.com:owner/repo.git\n  # - http://proxy@127.0.0.1:PORT/git/owner/repo\n\n  if echo \"$remote\" | grep -q \"github.com\"; then\n    repo=$(echo \"$remote\" | sed -E 's|.*github\\.com[:/]||' | sed 's|\\.git$||')\n  elif echo \"$remote\" | grep -q \"/git/\"; then\n    repo=$(echo \"$remote\" | sed -E 's|.*/git/||')\n  fi\n\n  echo \"$repo\"\n}\n\n# Ensure remote origin points directly to GitHub (not through proxy)\nensure_remote() {\n  local current_remote=$(git remote get-url origin 2>/dev/null || echo \"\")\n  local repo=$(get_github_repo)\n\n  if [ -z \"$repo\" ]; then\n    echo \"ERROR: Could not determine GitHub repo from remote\" >&2\n    echo \"Current remote: $current_remote\" >&2\n    exit 1\n  fi\n\n  # Check if remote is already correct (github.com, not proxy)\n  if echo \"$current_remote\" | grep -q \"github.com\"; then\n    return 0\n  fi\n\n  # Need to fix remote - check for GH_TOKEN\n  if [ -z \"$GH_TOKEN\" ]; then\n    echo \"ERROR: Remote needs fixing but GH_TOKEN is not set\" >&2\n    echo \"Current remote: $current_remote\" >&2\n    echo \"\" >&2\n    echo \"To fix: set GH_TOKEN environment variable with your GitHub token\" >&2\n    exit 1\n  fi\n\n  local auth_remote=\"https://x-access-token:${GH_TOKEN}@github.com/${repo}.git\"\n\n  echo \"Fixing remote origin...\"\n  echo \"  Was: $current_remote\"\n  echo \"  Now: https://***@github.com/${repo}.git\"\n\n  git remote set-url origin \"$auth_remote\"\n}\n\n# Ensure main branch exists locally\nensure_main_branch() {\n  # Check if main exists locally\n  if git show-ref --verify --quiet refs/heads/main; then\n    return 0\n  fi\n\n  echo \"Branch 'main' not found locally. Fetching...\"\n\n  # Try to fetch main from origin\n  if git fetch origin main:main 2>/dev/null; then\n    echo \"Fetched 'main' from origin.\"\n  else\n    # Maybe we need to create it from current HEAD\n    echo \"Creating 'main' branch from current HEAD...\"\n    git branch main\n  fi\n}\n\ncmd_sync() {\n  cd \"$SCRIPT_DIR\"\n\n  # Ensure remote is configured correctly\n  ensure_remote\n\n  # Ensure main branch exists\n  ensure_main_branch\n\n  # Check current branch\n  current_branch=$(git branch --show-current)\n\n  # Switch to main if needed\n  if [ \"$current_branch\" != \"main\" ]; then\n    echo \"Switching from '$current_branch' to 'main'...\"\n    git checkout main\n  fi\n\n  # Check for uncommitted changes\n  if git diff --quiet && git diff --staged --quiet; then\n    # Check for untracked files\n    if [ -z \"$(git ls-files --others --exclude-standard)\" ]; then\n      echo \"Nothing to sync.\"\n      exit 0\n    fi\n  fi\n\n  # Stage all changes\n  git add -A\n\n  # Commit with timestamp\n  timestamp=$(date '+%Y-%m-%d %H:%M')\n  git commit -m \"sync: $timestamp\"\n\n  echo \"Committed. Pushing to main...\"\n\n  # Try to push\n  if git push origin main 2>&1; then\n    echo \"Synced successfully.\"\n  else\n    echo \"\"\n    echo \"=== PUSH FAILED ===\"\n    echo \"Conflict detected. Pulling with rebase...\"\n    echo \"\"\n\n    # Try to pull and rebase\n    if git pull --rebase origin main 2>&1; then\n      echo \"Rebase successful. Pushing again...\"\n      if git push origin main 2>&1; then\n        echo \"Synced successfully after rebase.\"\n      else\n        echo \"\"\n        echo \"=== CRITICAL: Push still failing ===\"\n        echo \"Manual intervention required. Current status:\"\n        git status\n        exit 1\n      fi\n    else\n      echo \"\"\n      echo \"=== CRITICAL: Rebase conflict ===\"\n      echo \"Manual intervention required.\"\n      echo \"\"\n      echo \"Conflicting files:\"\n      git diff --name-only --diff-filter=U\n      echo \"\"\n      echo \"To resolve:\"\n      echo \"1. Edit conflicting files\"\n      echo \"2. git add <resolved files>\"\n      echo \"3. git rebase --continue\"\n      echo \"4. ./cli.sh sync\"\n      exit 1\n    fi\n  fi\n}\n\ncmd_read() {\n  cd \"$SCRIPT_DIR\"\n  local query=\"$1\"\n\n  if [ -z \"$query\" ]; then\n    echo \"Usage: ./cli.sh read <note-name or path>\" >&2\n    exit 1\n  fi\n\n  # Find the file\n  local file=\"\"\n\n  # If it's a direct path that exists\n  if [ -f \"$query\" ]; then\n    file=\"$query\"\n  elif [ -f \"$query.md\" ]; then\n    file=\"$query.md\"\n  else\n    # Search for Obsidian-style note name\n    file=$(find . -name \"*.md\" -type f | grep -i \"$query\" | head -1)\n  fi\n\n  if [ -z \"$file\" ] || [ ! -f \"$file\" ]; then\n    echo \"Note not found: $query\" >&2\n    exit 1\n  fi\n\n  # Get the basename for backlink search\n  local basename=$(basename \"$file\" .md)\n\n  # Print file content with line numbers (same format as Claude Read tool)\n  local abs_path=\"$(cd \"$(dirname \"$file\")\" && pwd)/$(basename \"$file\")\"\n  echo \"=== $abs_path ===\"\n  echo \"\"\n  awk '{printf \"%6dâ†’%s\\n\", NR, $0}' \"$file\"\n\n  # Find and print backlinks\n  echo \"\"\n  echo \"=== Backlinks ===\"\n\n  local backlinks=$(grep -rn \"\\[\\[$basename\" --include=\"*.md\" . 2>/dev/null | grep -v \"^$file:\" || true)\n\n  if [ -n \"$backlinks\" ]; then\n    echo \"$backlinks\"\n  else\n    echo \"(no backlinks)\"\n  fi\n}\n\ncmd_tasks() {\n  cd \"$SCRIPT_DIR\"\n\n  local path_filter=\"\"\n  local tag_filter=\"\"\n  local show_all=false\n\n  # Parse arguments\n  while [[ $# -gt 0 ]]; do\n    case \"$1\" in\n      --p1|--p2|--p3)\n        tag_filter=\"${1#--}\"\n        shift\n        ;;\n      --next|--waiting|--someday)\n        tag_filter=\"${1#--}\"\n        shift\n        ;;\n      --all)\n        show_all=true\n        shift\n        ;;\n      -*)\n        echo \"Unknown option: $1\" >&2\n        echo \"Usage: ./cli.sh tasks [path] [--p1|--p2|--p3|--next|--waiting|--someday] [--all]\" >&2\n        exit 1\n        ;;\n      *)\n        path_filter=\"$1\"\n        shift\n        ;;\n    esac\n  done\n\n  # Build search path\n  local search_path=\".\"\n  if [ -n \"$path_filter\" ]; then\n    # Find directories matching the filter\n    search_path=$(find . -type d -iname \"*$path_filter*\" 2>/dev/null | head -1)\n    if [ -z \"$search_path\" ]; then\n      # Try as a direct path\n      if [ -d \"$path_filter\" ]; then\n        search_path=\"$path_filter\"\n      else\n        echo \"No directory matching: $path_filter\" >&2\n        exit 1\n      fi\n    fi\n  fi\n\n  echo \"=== Tasks in $search_path ===\"\n  echo \"\"\n\n  # Find all unchecked tasks\n  local tasks\n  tasks=$(grep -rn \"\\- \\[ \\]\" --include=\"*.md\" \"$search_path\" 2>/dev/null || true)\n\n  if [ -z \"$tasks\" ]; then\n    echo \"No open tasks found.\"\n    return 0\n  fi\n\n  # Filter by tag if specified\n  if [ -n \"$tag_filter\" ]; then\n    tasks=$(echo \"$tasks\" | grep -i \"#$tag_filter\" || true)\n    if [ -z \"$tasks\" ]; then\n      echo \"No tasks with #$tag_filter\"\n      return 0\n    fi\n    echo \"Filtered by: #$tag_filter\"\n    echo \"\"\n  fi\n\n  # Group and display\n  local current_file=\"\"\n  local count=0\n\n  echo \"$tasks\" | while IFS= read -r line; do\n    # Extract file path and line number\n    local file=$(echo \"$line\" | cut -d: -f1)\n    local linenum=$(echo \"$line\" | cut -d: -f2)\n    local content=$(echo \"$line\" | cut -d: -f3-)\n\n    # Clean up content - remove leading spaces and the checkbox\n    content=$(echo \"$content\" | sed 's/^[[:space:]]*- \\[ \\] //')\n\n    # Print file header if new file\n    if [ \"$file\" != \"$current_file\" ]; then\n      if [ -n \"$current_file\" ]; then\n        echo \"\"\n      fi\n      echo \"$file\"\n      current_file=\"$file\"\n    fi\n\n    # Highlight priority tags\n    if echo \"$content\" | grep -q \"#p1\"; then\n      echo \"  [!] $content\"\n    elif echo \"$content\" | grep -q \"#p2\"; then\n      echo \"  [*] $content\"\n    elif echo \"$content\" | grep -q \"#p3\"; then\n      echo \"  [-] $content\"\n    elif echo \"$content\" | grep -q \"#next\"; then\n      echo \"  [>] $content\"\n    elif echo \"$content\" | grep -q \"#waiting\"; then\n      echo \"  [?] $content\"\n    elif echo \"$content\" | grep -q \"#someday\"; then\n      echo \"  [~] $content\"\n    else\n      echo \"  [ ] $content\"\n    fi\n\n    count=$((count + 1))\n  done\n\n  echo \"\"\n  echo \"---\"\n  local total=$(echo \"$tasks\" | wc -l | tr -d ' ')\n  echo \"Total: $total tasks\"\n}\n\ncmd_daily() {\n  cd \"$SCRIPT_DIR\"\n\n  # Get current date\n  local year=$(date '+%Y')\n  local month=$(date '+%m')\n  local date_str=$(date '+%Y-%m-%d')\n\n  # Ensure directory exists\n  local daily_dir=\"Daily/$year/$month\"\n  mkdir -p \"$daily_dir\"\n\n  # Ensure Briefs subfolder exists\n  mkdir -p \"$daily_dir/Briefs\"\n\n  # Create the daily note file\n  local daily_file=\"$daily_dir/$date_str.md\"\n\n  # Check if file already exists\n  if [ -f \"$daily_file\" ]; then\n    echo \"Daily note already exists: $daily_file\"\n  else\n    # Copy template if it exists\n    if [ -f \"Templates/Daily.md\" ]; then\n      cp \"Templates/Daily.md\" \"$daily_file\"\n      echo \"Created daily note: $daily_file\"\n    else\n      # Create basic template if none exists\n      cat > \"$daily_file\" << EOF\n# $date_str\n\n## ðŸŽ¯ #1 Priority\n\n## Workspace\n\n### Deep Work\n\n### Capture\n\n## Logbook\n\nEOF\n      echo \"Created daily note: $daily_file\"\n    fi\n  fi\n\n  # Open in Obsidian\n  \"$CLI_DIR/obsidian-cli\" open \"$daily_file\"\n}\n\ncmd_things() {\n  local list=\"${1:-today}\"\n\n  case \"$list\" in\n    today)\n      echo \"=== Things 3: Today ===\"\n      osascript -e 'tell application \"Things3\"\n        set output to \"\"\n        repeat with t in to dos of list \"Today\"\n          set taskName to name of t\n          set taskArea to \"\"\n          set taskDue to \"\"\n          try\n            set taskArea to name of area of t\n          end try\n          try\n            set taskDue to due date of t as string\n          end try\n          if taskArea is not \"\" then\n            set output to output & \"[\" & taskArea & \"] \"\n          end if\n          set output to output & taskName\n          if taskDue is not \"\" then\n            set output to output & \" ðŸ“… \" & taskDue\n          end if\n          set output to output & \"\\n\"\n        end repeat\n        return output\n      end tell'\n      ;;\n    anytime)\n      echo \"=== Things 3: Anytime ===\"\n      osascript -e 'tell application \"Things3\"\n        set output to \"\"\n        repeat with t in to dos of list \"Anytime\"\n          set taskName to name of t\n          set taskArea to \"\"\n          try\n            set taskArea to name of area of t\n          end try\n          if taskArea is not \"\" then\n            set output to output & \"[\" & taskArea & \"] \"\n          end if\n          set output to output & taskName & \"\\n\"\n        end repeat\n        return output\n      end tell' | head -30\n      ;;\n    areas)\n      echo \"=== Things 3: Tasks by Area ===\"\n      osascript -e 'tell application \"Things3\"\n        set output to \"\"\n        repeat with a in areas\n          set areaName to name of a\n          set areaTasks to to dos of a\n          if (count of areaTasks) > 0 then\n            set output to output & \"\\n\" & areaName & \":\\n\"\n            repeat with t in areaTasks\n              set taskName to name of t\n              set output to output & \"  - \" & taskName & \"\\n\"\n            end repeat\n          end if\n        end repeat\n        return output\n      end tell'\n      ;;\n    *)\n      echo \"Usage: ./cli.sh things [today|anytime|areas]\"\n      ;;\n  esac\n}\n\ncmd_status() {\n  cd \"$SCRIPT_DIR\"\n\n  echo \"=== Git Status ===\"\n\n  # Branch\n  branch=$(git branch --show-current)\n  echo \"Branch: $branch\"\n\n  # Uncommitted changes\n  changes=$(git status --porcelain | wc -l | tr -d ' ')\n  if [ \"$changes\" -gt 0 ]; then\n    echo \"Uncommitted changes: $changes files\"\n    git status --short\n  else\n    echo \"Working tree clean.\"\n  fi\n\n  # Ahead/behind\n  git fetch origin main --quiet 2>/dev/null || true\n  ahead=$(git rev-list --count origin/main..HEAD 2>/dev/null || echo \"0\")\n  behind=$(git rev-list --count HEAD..origin/main 2>/dev/null || echo \"0\")\n\n  if [ \"$ahead\" -gt 0 ] || [ \"$behind\" -gt 0 ]; then\n    echo \"Ahead: $ahead, Behind: $behind\"\n  fi\n}\n\n# === Main ===\n\ncase \"${1:-}\" in\n  sync)\n    cmd_sync\n    ;;\n  status)\n    cmd_status\n    ;;\n  read)\n    cmd_read \"$2\"\n    ;;\n  daily)\n    cmd_daily\n    ;;\n  tasks)\n    shift\n    cmd_tasks \"$@\"\n    ;;\n  things)\n    shift\n    cmd_things \"$@\"\n    ;;\n  help|--help|-h)\n    echo \"Usage: ./cli.sh <command>\"\n    echo \"\"\n    echo \"Custom commands:\"\n    echo \"  sync              Commit all changes and push to main\"\n    echo \"  status            Show git status summary\"\n    echo \"  read <note>       Read note with backlinks\"\n    echo \"  daily             Open/create today's daily note\"\n    echo \"  tasks [path]      List open tasks\"\n    echo \"        --p1/p2/p3  Filter by priority\"\n    echo \"        --next      Filter by #next tag\"\n    echo \"  things [list]     Query Things 3\"\n    echo \"        today       Today list (default)\"\n    echo \"        anytime     Anytime list\"\n    echo \"        areas       Tasks grouped by area\"\n    echo \"\"\n    echo \"Obsidian commands:\"\n    ensure_binary\n    \"$CLI_DIR/obsidian-cli\" --help\n    ;;\n  *)\n    ensure_binary\n    exec \"$CLI_DIR/obsidian-cli\" \"$@\"\n    ;;\nesac\n"
    },
    "toolu_01VEGek5tYY2f7bqQ5fvhYgN": {
      "filePath": ".obsidian/plugins/templater-obsidian/data.json",
      "originalContent": "{\n  \"command_timeout\": 5,\n  \"templates_folder\": \"Templates\",\n  \"templates_pairs\": [\n    [\n      \"calendar\",\n      \"~/.config/obsidian-scripts/calendar.sh\\n\"\n    ]\n  ],\n  \"trigger_on_file_creation\": true,\n  \"auto_jump_to_cursor\": false,\n  \"enable_system_commands\": true,\n  \"shell_path\": \"\",\n  \"user_scripts_folder\": \"Scripts\",\n  \"enable_folder_templates\": true,\n  \"folder_templates\": [\n    {\n      \"folder\": \"Daily\",\n      \"template\": \"Templates/Daily.md\"\n    },\n    {\n      \"folder\": \"Daily/2026\",\n      \"template\": \"Templates/Daily.md\"\n    }\n  ],\n  \"enable_file_templates\": false,\n  \"file_templates\": [\n    {\n      \"regex\": \".*\",\n      \"template\": \"\"\n    }\n  ],\n  \"syntax_highlighting\": true,\n  \"syntax_highlighting_mobile\": false,\n  \"enabled_templates_hotkeys\": [\n    \"\"\n  ],\n  \"startup_templates\": [\n    \"\"\n  ],\n  \"intellisense_render\": 1\n}",
      "newContent": "{\n  \"command_timeout\": 5,\n  \"templates_folder\": \"Templates\",\n  \"templates_pairs\": [\n    [\n      \"calendar\",\n      \"~/.config/obsidian-scripts/calendar.sh\\n\"\n    ],\n    [\n      \"daily\",\n      \"cd '/Users/karthik/Documents/3 - Resources/Vaults/SecondBrain26' && ./cli.sh daily\\n\"\n    ]\n  ],\n  \"trigger_on_file_creation\": true,\n  \"auto_jump_to_cursor\": false,\n  \"enable_system_commands\": true,\n  \"shell_path\": \"\",\n  \"user_scripts_folder\": \"Scripts\",\n  \"enable_folder_templates\": true,\n  \"folder_templates\": [\n    {\n      \"folder\": \"Daily\",\n      \"template\": \"Templates/Daily.md\"\n    },\n    {\n      \"folder\": \"Daily/2026\",\n      \"template\": \"Templates/Daily.md\"\n    }\n  ],\n  \"enable_file_templates\": false,\n  \"file_templates\": [\n    {\n      \"regex\": \".*\",\n      \"template\": \"\"\n    }\n  ],\n  \"syntax_highlighting\": true,\n  \"syntax_highlighting_mobile\": false,\n  \"enabled_templates_hotkeys\": [\n    \"\"\n  ],\n  \"startup_templates\": [\n    \"\"\n  ],\n  \"intellisense_render\": 1\n}"
    },
    "toolu_01QZwdWrWq8mRuGrHciEko2D": {
      "filePath": ".obsidian/community-plugins.json",
      "originalContent": "[\n  \"obsidian42-brat\",\n  \"claudian\",\n  \"obsidian-things3-sync\",\n  \"things3-today\",\n  \"obsidian-tasks-plugin\",\n  \"templater-obsidian\",\n  \"obsidian-tracker\",\n  \"dataview\",\n  \"things-logbook\",\n  \"obsidian-paste-image-rename\"\n]",
      "newContent": "[\n  \"obsidian42-brat\",\n  \"claudian\",\n  \"obsidian-things3-sync\",\n  \"things3-today\",\n  \"obsidian-tasks-plugin\",\n  \"templater-obsidian\",\n  \"obsidian-tracker\",\n  \"dataview\",\n  \"things-logbook\",\n  \"obsidian-paste-image-rename\",\n  \"periodic-notes\"\n]"
    },
    "toolu_01D5F2v89ZTKup3KHRAQvDqM": {
      "filePath": ".obsidian/core-plugins.json",
      "originalContent": "{\n  \"file-explorer\": true,\n  \"global-search\": true,\n  \"switcher\": true,\n  \"graph\": true,\n  \"backlink\": true,\n  \"canvas\": true,\n  \"outgoing-link\": true,\n  \"tag-pane\": true,\n  \"footnotes\": false,\n  \"properties\": true,\n  \"page-preview\": true,\n  \"daily-notes\": true,\n  \"templates\": true,\n  \"note-composer\": true,\n  \"command-palette\": true,\n  \"slash-command\": false,\n  \"editor-status\": true,\n  \"bookmarks\": true,\n  \"markdown-importer\": false,\n  \"zk-prefixer\": false,\n  \"random-note\": false,\n  \"outline\": true,\n  \"word-count\": true,\n  \"slides\": false,\n  \"audio-recorder\": false,\n  \"workspaces\": false,\n  \"file-recovery\": true,\n  \"publish\": false,\n  \"sync\": true,\n  \"bases\": true,\n  \"webviewer\": false\n}",
      "newContent": "{\n  \"file-explorer\": true,\n  \"global-search\": true,\n  \"switcher\": true,\n  \"graph\": true,\n  \"backlink\": true,\n  \"canvas\": true,\n  \"outgoing-link\": true,\n  \"tag-pane\": true,\n  \"footnotes\": false,\n  \"properties\": true,\n  \"page-preview\": true,\n  \"daily-notes\": false,\n  \"templates\": true,\n  \"note-composer\": true,\n  \"command-palette\": true,\n  \"slash-command\": false,\n  \"editor-status\": true,\n  \"bookmarks\": true,\n  \"markdown-importer\": false,\n  \"zk-prefixer\": false,\n  \"random-note\": false,\n  \"outline\": true,\n  \"word-count\": true,\n  \"slides\": false,\n  \"audio-recorder\": false,\n  \"workspaces\": false,\n  \"file-recovery\": true,\n  \"publish\": false,\n  \"sync\": true,\n  \"bases\": true,\n  \"webviewer\": false\n}"
    },
    "toolu_01SYHy9PMvqvBVbL26VEzsMT": {
      "filePath": ".obsidian/community-plugins.json",
      "originalContent": "[\n  \"obsidian42-brat\",\n  \"claudian\",\n  \"obsidian-things3-sync\",\n  \"things3-today\",\n  \"obsidian-tasks-plugin\",\n  \"templater-obsidian\",\n  \"obsidian-tracker\",\n  \"dataview\",\n  \"things-logbook\",\n  \"obsidian-paste-image-rename\",\n  \"calendar\"\n]",
      "newContent": "[\n  \"obsidian42-brat\",\n  \"claudian\",\n  \"obsidian-things3-sync\",\n  \"things3-today\",\n  \"obsidian-tasks-plugin\",\n  \"templater-obsidian\",\n  \"obsidian-tracker\",\n  \"dataview\",\n  \"things-logbook\",\n  \"obsidian-paste-image-rename\",\n  \"calendar\",\n  \"periodic-notes\"\n]"
    },
    "toolu_01RRv6638nzAFs1tJkikpkXU": {
      "filePath": ".obsidian/plugins/periodic-notes/data.json",
      "originalContent": "{\n  \"showGettingStartedBanner\": true,\n  \"hasMigratedDailyNoteSettings\": true,\n  \"hasMigratedWeeklyNoteSettings\": false,\n  \"daily\": {\n    \"format\": \"YYYY-MM-DD\",\n    \"folder\": \"Daily/YYYY/MM\",\n    \"template\": \"Templates/Daily.md\",\n    \"enabled\": true\n  },\n  \"weekly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"monthly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"quarterly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"yearly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  }\n}",
      "newContent": "{\n  \"showGettingStartedBanner\": false,\n  \"hasMigratedDailyNoteSettings\": true,\n  \"hasMigratedWeeklyNoteSettings\": false,\n  \"daily\": {\n    \"format\": \"YYYY-MM-DD\",\n    \"folder\": \"Daily/YYYY/MM\",\n    \"template\": \"Templates/Daily\",\n    \"enabled\": true\n  },\n  \"weekly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"monthly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"quarterly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"yearly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  }\n}"
    },
    "toolu_01AbTyXbRcM29Hoq5dEGjvAQ": {
      "filePath": ".obsidian/plugins/periodic-notes/data.json",
      "originalContent": "{\n  \"showGettingStartedBanner\": false,\n  \"hasMigratedDailyNoteSettings\": true,\n  \"hasMigratedWeeklyNoteSettings\": false,\n  \"daily\": {\n    \"format\": \"YYYY-MM-DD\",\n    \"folder\": \"Daily/YYYY/MM\",\n    \"template\": \"Templates/Daily\",\n    \"enabled\": true\n  },\n  \"weekly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"monthly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"quarterly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"yearly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  }\n}",
      "newContent": "{\n  \"showGettingStartedBanner\": false,\n  \"hasMigratedDailyNoteSettings\": true,\n  \"hasMigratedWeeklyNoteSettings\": false,\n  \"daily\": {\n    \"format\": \"YYYY-MM-DD\",\n    \"folder\": \"Daily/YYYY/MM\",\n    \"template\": \"Templates/Daily.md\",\n    \"enabled\": true\n  },\n  \"weekly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"monthly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"quarterly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  },\n  \"yearly\": {\n    \"format\": \"\",\n    \"template\": \"\",\n    \"folder\": \"\"\n  }\n}"
    },
    "toolu_018Zda5jjBfbzJRjhyb9Kxzo": {
      "filePath": ".obsidian/core-plugins.json",
      "originalContent": "{\n  \"file-explorer\": true,\n  \"global-search\": true,\n  \"switcher\": true,\n  \"graph\": true,\n  \"backlink\": true,\n  \"canvas\": true,\n  \"outgoing-link\": true,\n  \"tag-pane\": true,\n  \"footnotes\": false,\n  \"properties\": true,\n  \"page-preview\": true,\n  \"daily-notes\": true,\n  \"templates\": true,\n  \"note-composer\": true,\n  \"command-palette\": true,\n  \"slash-command\": false,\n  \"editor-status\": true,\n  \"bookmarks\": true,\n  \"markdown-importer\": false,\n  \"zk-prefixer\": false,\n  \"random-note\": false,\n  \"outline\": true,\n  \"word-count\": true,\n  \"slides\": false,\n  \"audio-recorder\": false,\n  \"workspaces\": false,\n  \"file-recovery\": true,\n  \"publish\": false,\n  \"sync\": true,\n  \"bases\": true,\n  \"webviewer\": false\n}",
      "newContent": "{\n  \"file-explorer\": true,\n  \"global-search\": true,\n  \"switcher\": true,\n  \"graph\": true,\n  \"backlink\": true,\n  \"canvas\": true,\n  \"outgoing-link\": true,\n  \"tag-pane\": true,\n  \"footnotes\": false,\n  \"properties\": true,\n  \"page-preview\": true,\n  \"daily-notes\": false,\n  \"templates\": true,\n  \"note-composer\": true,\n  \"command-palette\": true,\n  \"slash-command\": false,\n  \"editor-status\": true,\n  \"bookmarks\": true,\n  \"markdown-importer\": false,\n  \"zk-prefixer\": false,\n  \"random-note\": false,\n  \"outline\": true,\n  \"word-count\": true,\n  \"slides\": false,\n  \"audio-recorder\": false,\n  \"workspaces\": false,\n  \"file-recovery\": true,\n  \"publish\": false,\n  \"sync\": true,\n  \"bases\": true,\n  \"webviewer\": false\n}"
    }
  }
}