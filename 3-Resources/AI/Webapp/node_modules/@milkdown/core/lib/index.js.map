{"version":3,"file":"index.js","sources":["../src/__internal__/utils.ts","../src/__internal__/remark-handlers.ts","../src/internal-plugin/atoms.ts","../src/internal-plugin/config.ts","../src/internal-plugin/init.ts","../src/internal-plugin/schema.ts","../src/internal-plugin/commands.ts","../src/internal-plugin/keymap.ts","../src/internal-plugin/parser.ts","../src/internal-plugin/serializer.ts","../src/internal-plugin/editor-state.ts","../src/internal-plugin/paste-rule.ts","../src/internal-plugin/editor-view.ts","../src/editor/editor.ts"],"sourcesContent":["import type { Meta, MilkdownPlugin } from '@milkdown/ctx'\n\nexport function withMeta<T extends MilkdownPlugin>(\n  plugin: T,\n  meta: Partial<Meta> & Pick<Meta, 'displayName'>\n): T {\n  plugin.meta = {\n    package: '@milkdown/core',\n    group: 'System',\n    ...meta,\n  }\n\n  return plugin\n}\n","import type { Options } from 'remark-stringify'\n\nexport const remarkHandlers: Required<Options>['handlers'] = {\n  text: (node, _, state, info) => {\n    // This config is to remove the `&#20;` entity when have trailing spaces\n    const value = node.value\n    // Check if the text contains only trailing spaces that might be encoded\n    if (/^[^*_\\\\]*\\s+$/.test(value)) {\n      // For text that ends with spaces but has no markdown special characters that need escaping,\n      // return the value directly to preserve trailing spaces\n      return value\n    }\n    // For other text, use safe to handle markdown escaping but prevent space encoding\n    return state.safe(value, { ...info, encode: [] })\n  },\n  strong: (node, _, state, info) => {\n    const marker = node.marker || state.options.strong || '*'\n    const exit = state.enter('strong')\n    const tracker = state.createTracker(info)\n    let value = tracker.move(marker + marker)\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: marker,\n        ...tracker.current(),\n      })\n    )\n    value += tracker.move(marker + marker)\n    exit()\n    return value\n  },\n  emphasis: (node, _, state, info) => {\n    const marker = node.marker || state.options.emphasis || '*'\n    const exit = state.enter('emphasis')\n    const tracker = state.createTracker(info)\n    let value = tracker.move(marker)\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: marker,\n        ...tracker.current(),\n      })\n    )\n    value += tracker.move(marker)\n    exit()\n    return value\n  },\n}\n","import type { SliceType, TimerType } from '@milkdown/ctx'\nimport type { InputRule } from '@milkdown/prose/inputrules'\nimport type { EditorState, Plugin } from '@milkdown/prose/state'\nimport type {\n  EditorView,\n  MarkViewConstructor,\n  NodeViewConstructor,\n} from '@milkdown/prose/view'\nimport type { RemarkParser, RemarkPlugin } from '@milkdown/transformer'\nimport type { Options } from 'remark-stringify'\n\nimport { createSlice } from '@milkdown/ctx'\nimport remarkParse from 'remark-parse'\nimport remarkStringify from 'remark-stringify'\nimport { unified } from 'unified'\n\nimport type { Editor } from '../editor'\n\nimport { remarkHandlers } from '../__internal__'\n\n/// A slice which contains the editor view instance.\nexport const editorViewCtx = createSlice({} as EditorView, 'editorView')\n\n/// A slice which contains the editor state.\nexport const editorStateCtx = createSlice({} as EditorState, 'editorState')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[ConfigReady]`.\nexport const initTimerCtx = createSlice([] as TimerType[], 'initTimer')\n\n/// A slice which stores the editor instance.\nexport const editorCtx = createSlice({} as Editor, 'editor')\n\n/// A slice which stores the input rules.\nexport const inputRulesCtx = createSlice([] as InputRule[], 'inputRules')\n\n/// A slice which stores the prosemirror plugins.\nexport const prosePluginsCtx = createSlice([] as Plugin[], 'prosePlugins')\n\n/// A slice which stores the remark plugins.\nexport const remarkPluginsCtx = createSlice(\n  [] as RemarkPlugin[],\n  'remarkPlugins'\n)\n\ntype NodeView = [nodeId: string, view: NodeViewConstructor]\n\n/// A slice which stores the prosemirror node views.\nexport const nodeViewCtx = createSlice([] as NodeView[], 'nodeView')\n\ntype MarkView = [nodeId: string, view: MarkViewConstructor]\n\n/// A slice which stores the prosemirror mark views.\nexport const markViewCtx = createSlice([] as MarkView[], 'markView')\n\n/// A slice which stores the remark instance.\nexport const remarkCtx: SliceType<RemarkParser, 'remark'> = createSlice(\n  unified().use(remarkParse).use(remarkStringify),\n  'remark'\n)\n\n/// A slice which stores the remark stringify options.\nexport const remarkStringifyOptionsCtx = createSlice(\n  {\n    handlers: remarkHandlers,\n    encode: [],\n  } as Options,\n  'remarkStringifyOptions'\n)\n","import type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\n\nimport { createTimer } from '@milkdown/ctx'\n\nimport { withMeta } from '../__internal__'\n\n/// @internal\nexport type Config = (ctx: Ctx) => void | Promise<void>\n\n/// The timer which will be resolved when the config plugin is ready.\nexport const ConfigReady = createTimer('ConfigReady')\n\n/// The config plugin.\n/// This plugin will load all user configs.\nexport function config(configure: Config): MilkdownPlugin {\n  const plugin: MilkdownPlugin = (ctx) => {\n    ctx.record(ConfigReady)\n\n    return async () => {\n      await configure(ctx)\n      ctx.done(ConfigReady)\n\n      return () => {\n        ctx.clearTimer(ConfigReady)\n      }\n    }\n  }\n\n  withMeta(plugin, {\n    displayName: 'Config',\n  })\n\n  return plugin\n}\n","import type { MilkdownPlugin } from '@milkdown/ctx'\n\nimport { createTimer } from '@milkdown/ctx'\nimport remarkParse from 'remark-parse'\nimport remarkStringify, { type Options } from 'remark-stringify'\nimport { unified } from 'unified'\n\nimport type { Editor } from '../editor'\n\nimport { remarkHandlers, withMeta } from '../__internal__'\nimport {\n  editorCtx,\n  initTimerCtx,\n  inputRulesCtx,\n  markViewCtx,\n  nodeViewCtx,\n  prosePluginsCtx,\n  remarkCtx,\n  remarkPluginsCtx,\n  remarkStringifyOptionsCtx,\n} from './atoms'\nimport { ConfigReady } from './config'\n\n/// The timer which will be resolved when the init plugin is ready.\nexport const InitReady = createTimer('InitReady')\n\n/// The init plugin.\n/// This plugin prepare slices that needed by other plugins. And create a remark instance.\n///\n/// This plugin will wait for the config plugin.\nexport function init(editor: Editor): MilkdownPlugin {\n  const plugin: MilkdownPlugin = (ctx) => {\n    ctx\n      .inject(editorCtx, editor)\n      .inject(prosePluginsCtx, [])\n      .inject(remarkPluginsCtx, [])\n      .inject(inputRulesCtx, [])\n      .inject(nodeViewCtx, [])\n      .inject(markViewCtx, [])\n      .inject(remarkStringifyOptionsCtx, {\n        handlers: remarkHandlers,\n        encode: [],\n      } as Options)\n      .inject(remarkCtx, unified().use(remarkParse).use(remarkStringify))\n      .inject(initTimerCtx, [ConfigReady])\n      .record(InitReady)\n\n    return async () => {\n      await ctx.waitTimers(initTimerCtx)\n      const options = ctx.get(remarkStringifyOptionsCtx)\n      ctx.set(\n        remarkCtx,\n        unified().use(remarkParse).use(remarkStringify, options)\n      )\n\n      ctx.done(InitReady)\n\n      return () => {\n        ctx\n          .remove(editorCtx)\n          .remove(prosePluginsCtx)\n          .remove(remarkPluginsCtx)\n          .remove(inputRulesCtx)\n          .remove(nodeViewCtx)\n          .remove(markViewCtx)\n          .remove(remarkStringifyOptionsCtx)\n          .remove(remarkCtx)\n          .remove(initTimerCtx)\n          .clearTimer(InitReady)\n      }\n    }\n  }\n  withMeta(plugin, {\n    displayName: 'Init',\n  })\n\n  return plugin\n}\n","import type { MilkdownPlugin, TimerType } from '@milkdown/ctx'\nimport type {\n  MarkSchema,\n  NodeSchema,\n  RemarkParser,\n} from '@milkdown/transformer'\n\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport { Schema } from '@milkdown/prose/model'\n\nimport { withMeta } from '../__internal__'\nimport { remarkCtx, remarkPluginsCtx } from './atoms'\nimport { InitReady } from './init'\n\n/// The timer which will be resolved when the schema plugin is ready.\nexport const SchemaReady = createTimer('SchemaReady')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[InitReady]`.\nexport const schemaTimerCtx = createSlice([] as TimerType[], 'schemaTimer')\n\n/// A slice which contains the schema.\nexport const schemaCtx = createSlice({} as Schema, 'schema')\n\n/// A slice which stores the nodes spec.\nexport const nodesCtx = createSlice([] as Array<[string, NodeSchema]>, 'nodes')\n\n/// A slice which stores the marks spec.\nexport const marksCtx = createSlice([] as Array<[string, MarkSchema]>, 'marks')\n\nfunction extendPriority<T extends NodeSchema | MarkSchema>(x: T): T {\n  return {\n    ...x,\n    parseDOM: x.parseDOM?.map((rule) => ({ priority: x.priority, ...rule })),\n  }\n}\n\n/// The schema plugin.\n/// This plugin will load all nodes spec and marks spec and create a schema.\n///\n/// This plugin will wait for the init plugin.\nexport const schema: MilkdownPlugin = (ctx) => {\n  ctx\n    .inject(schemaCtx, {} as Schema)\n    .inject(nodesCtx, [])\n    .inject(marksCtx, [])\n    .inject(schemaTimerCtx, [InitReady])\n    .record(SchemaReady)\n\n  return async () => {\n    await ctx.waitTimers(schemaTimerCtx)\n\n    const remark = ctx.get(remarkCtx)\n    const remarkPlugins = ctx.get(remarkPluginsCtx)\n\n    const processor = remarkPlugins.reduce(\n      (acc: RemarkParser, plug) =>\n        acc.use(plug.plugin, plug.options) as unknown as RemarkParser,\n      remark\n    )\n    ctx.set(remarkCtx, processor)\n\n    const nodes = Object.fromEntries(\n      ctx.get(nodesCtx).map(([key, x]) => [key, extendPriority(x)])\n    )\n    const marks = Object.fromEntries(\n      ctx.get(marksCtx).map(([key, x]) => [key, extendPriority(x)])\n    )\n    const schema = new Schema({ nodes, marks })\n\n    ctx.set(schemaCtx, schema)\n\n    ctx.done(SchemaReady)\n\n    return () => {\n      ctx\n        .remove(schemaCtx)\n        .remove(nodesCtx)\n        .remove(marksCtx)\n        .remove(schemaTimerCtx)\n        .clearTimer(SchemaReady)\n    }\n  }\n}\n\nwithMeta(schema, {\n  displayName: 'Schema',\n})\n","import type { Ctx, MilkdownPlugin, SliceType } from '@milkdown/ctx'\nimport type { Command } from '@milkdown/prose/state'\n\nimport { Container, createSlice, createTimer } from '@milkdown/ctx'\nimport { callCommandBeforeEditorView } from '@milkdown/exception'\nimport { chainCommands } from '@milkdown/prose/commands'\n\nimport { withMeta } from '../__internal__'\nimport { editorViewCtx } from './atoms'\nimport { SchemaReady } from './schema'\n\n/// @internal\nexport type Cmd<T = undefined> = (payload?: T) => Command\n\n/// @internal\nexport type CmdKey<T = undefined> = SliceType<Cmd<T>>\n\ntype InferParams<T> = T extends CmdKey<infer U> ? U : never\n\n/// A chainable command helper.\nexport interface CommandChain {\n  /// Run the command chain.\n  run: () => boolean\n  /// Add an inline command to the chain.\n  inline: (command: Command) => CommandChain\n  /// Add a registered command to the chain.\n  pipe: {\n    <T extends CmdKey<any>>(\n      slice: string,\n      payload?: InferParams<T>\n    ): CommandChain\n    <T>(slice: CmdKey<T>, payload?: T): CommandChain\n    (slice: string | CmdKey<any>, payload?: any): CommandChain\n  }\n}\n\n/// The command manager.\n/// This manager will manage all commands in editor.\n/// Generally, you don't need to use this manager directly.\n/// You can use the `$command` and `$commandAsync` in `@milkdown/utils` to create and call a command.\nexport class CommandManager {\n  /// @internal\n  #container = new Container()\n\n  /// @internal\n  #ctx: Ctx | null = null\n\n  /// @internal\n  setCtx = (ctx: Ctx) => {\n    this.#ctx = ctx\n  }\n\n  get ctx() {\n    return this.#ctx\n  }\n\n  /// Register a command into the manager.\n  create<T>(meta: CmdKey<T>, value: Cmd<T>) {\n    const slice = meta.create(this.#container.sliceMap)\n    slice.set(value)\n    return slice\n  }\n\n  /// Get a command from the manager.\n  get<T extends CmdKey<any>>(slice: string): Cmd<InferParams<T>>\n  get<T>(slice: CmdKey<T>): Cmd<T>\n  get(slice: string | CmdKey<any>): Cmd<any>\n  get(slice: string | CmdKey<any>): Cmd<any> {\n    return this.#container.get(slice).get()\n  }\n\n  /// Remove a command from the manager.\n  remove<T extends CmdKey<any>>(slice: string): void\n  remove<T>(slice: CmdKey<T>): void\n  remove(slice: string | CmdKey<any>): void\n  remove(slice: string | CmdKey<any>): void {\n    return this.#container.remove(slice)\n  }\n\n  /// Call a registered command.\n  call<T extends CmdKey<any>>(slice: string, payload?: InferParams<T>): boolean\n  call<T>(slice: CmdKey<T>, payload?: T): boolean\n  call(slice: string | CmdKey<any>, payload?: any): boolean\n  call(slice: string | CmdKey<any>, payload?: any): boolean {\n    if (this.#ctx == null) throw callCommandBeforeEditorView()\n\n    const cmd = this.get(slice)\n    const command = cmd(payload)\n    const view = this.#ctx.get(editorViewCtx)\n    return command(view.state, view.dispatch, view)\n  }\n\n  /// Call an inline command.\n  inline(command: Command) {\n    if (this.#ctx == null) throw callCommandBeforeEditorView()\n    const view = this.#ctx.get(editorViewCtx)\n    return command(view.state, view.dispatch, view)\n  }\n\n  /// Create a command chain.\n  /// All commands added by `pipe` will be run in order until one of them returns `true`.\n  chain = (): CommandChain => {\n    if (this.#ctx == null) throw callCommandBeforeEditorView()\n    const ctx = this.#ctx\n    const commands: Command[] = []\n    const get = this.get.bind(this)\n\n    const chains: CommandChain = {\n      run: () => {\n        const chained = chainCommands(...commands)\n        const view = ctx.get(editorViewCtx)\n        return chained(view.state, view.dispatch, view)\n      },\n      inline: (command: Command) => {\n        commands.push(command)\n        return chains\n      },\n      pipe: pipe.bind(this),\n    }\n\n    function pipe<T extends CmdKey<any>>(\n      slice: string,\n      payload?: InferParams<T>\n    ): typeof chains\n    function pipe<T>(slice: CmdKey<T>, payload?: T): typeof chains\n    function pipe(slice: string | CmdKey<any>, payload?: any): typeof chains\n    function pipe(slice: string | CmdKey<any>, payload?: any) {\n      const cmd = get(slice)\n      commands.push(cmd(payload))\n      return chains\n    }\n\n    return chains\n  }\n}\n\n/// Create a command key, which is a slice type that contains a command.\nexport function createCmdKey<T = undefined>(key = 'cmdKey'): CmdKey<T> {\n  return createSlice((() => () => false) as Cmd<T>, key)\n}\n\n/// A slice which contains the command manager.\nexport const commandsCtx = createSlice(new CommandManager(), 'commands')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[SchemaReady]`.\nexport const commandsTimerCtx = createSlice([SchemaReady], 'commandsTimer')\n\n/// The timer which will be resolved when the commands plugin is ready.\nexport const CommandsReady = createTimer('CommandsReady')\n\n/// The commands plugin.\n/// This plugin will create a command manager.\n///\n/// This plugin will wait for the schema plugin.\nexport const commands: MilkdownPlugin = (ctx) => {\n  const cmd = new CommandManager()\n  cmd.setCtx(ctx)\n  ctx\n    .inject(commandsCtx, cmd)\n    .inject(commandsTimerCtx, [SchemaReady])\n    .record(CommandsReady)\n  return async () => {\n    await ctx.waitTimers(commandsTimerCtx)\n\n    ctx.done(CommandsReady)\n\n    return () => {\n      ctx.remove(commandsCtx).remove(commandsTimerCtx).clearTimer(CommandsReady)\n    }\n  }\n}\n\nwithMeta(commands, {\n  displayName: 'Commands',\n})\n","import type { Command } from '@milkdown/prose/state'\n\nimport {\n  createSlice,\n  createTimer,\n  type Ctx,\n  type MilkdownPlugin,\n  type SliceType,\n} from '@milkdown/ctx'\nimport { ctxCallOutOfScope } from '@milkdown/exception'\nimport {\n  baseKeymap,\n  chainCommands,\n  deleteSelection,\n  joinTextblockBackward,\n  selectNodeBackward,\n} from '@milkdown/prose/commands'\nimport { undoInputRule } from '@milkdown/prose/inputrules'\n\nimport { SchemaReady } from './schema'\n\n/// @internal\nexport type KeymapItem = {\n  key: string\n  onRun: (ctx: Ctx) => Command\n  priority?: number\n}\n\n/// @internal\nexport type KeymapKey = SliceType<KeymapItem>\n\nfunction overrideBaseKeymap(keymap: Record<string, Command>) {\n  const handleBackspace = chainCommands(\n    undoInputRule,\n    deleteSelection,\n    joinTextblockBackward,\n    selectNodeBackward\n  )\n  keymap.Backspace = handleBackspace\n  return keymap\n}\n\n/// The keymap manager.\n/// This class is used to manage the keymap.\nexport class KeymapManager {\n  /// @internal\n  #ctx: Ctx | null = null\n\n  #keymap: KeymapItem[] = []\n\n  /// @internal\n  setCtx = (ctx: Ctx) => {\n    this.#ctx = ctx\n  }\n\n  get ctx() {\n    return this.#ctx\n  }\n\n  /// Add a keymap item.\n  /// When not passing a priority, the priority will be 50.\n  /// For the same key, the keymap with higher priority will be executed first.\n  /// If the priority is the same, the keymap will be executed in the order of addition.\n  add = (keymap: KeymapItem) => {\n    this.#keymap.push(keymap)\n\n    return () => {\n      this.#keymap = this.#keymap.filter((item) => item !== keymap)\n    }\n  }\n\n  /// Add an object of keymap items.\n  addObjectKeymap = (keymaps: Record<string, Command | KeymapItem>) => {\n    const remove: (() => void)[] = []\n    Object.entries(keymaps).forEach(([key, command]) => {\n      if (typeof command === 'function') {\n        const keymapItem = {\n          key,\n          onRun: () => command,\n        }\n\n        this.#keymap.push(keymapItem)\n        remove.push(() => {\n          this.#keymap = this.#keymap.filter((item) => item !== keymapItem)\n        })\n      } else {\n        this.#keymap.push(command)\n        remove.push(() => {\n          this.#keymap = this.#keymap.filter((item) => item !== command)\n        })\n      }\n    })\n\n    return () => {\n      remove.forEach((fn) => fn())\n    }\n  }\n\n  /// Add the prosemirror base keymap.\n  addBaseKeymap = () => {\n    const base = overrideBaseKeymap(baseKeymap)\n    return this.addObjectKeymap(base)\n  }\n\n  /// @internal\n  build = () => {\n    const keymap: Record<string, KeymapItem[]> = {}\n    this.#keymap.forEach((item) => {\n      keymap[item.key] = [...(keymap[item.key] || []), item]\n    })\n\n    const output: Record<string, Command> = Object.fromEntries(\n      Object.entries(keymap).map(([key, items]) => {\n        const sortedItems = items.sort(\n          (a, b) => (b.priority ?? 50) - (a.priority ?? 50)\n        )\n\n        const command: Command = (state, dispatch, view) => {\n          const ctx = this.#ctx\n          if (ctx == null) throw ctxCallOutOfScope()\n\n          const commands = sortedItems.map((item) => item.onRun(ctx))\n          const chained = chainCommands(...commands)\n\n          return chained(state, dispatch, view)\n        }\n\n        return [key, command] as const\n      })\n    )\n\n    return output\n  }\n}\n\n/// A slice which stores the keymap manager.\nexport const keymapCtx = createSlice(new KeymapManager(), 'keymap')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[SchemaReady]`.\nexport const keymapTimerCtx = createSlice([SchemaReady], 'keymapTimer')\n\n/// The timer which will be resolved when the keymap plugin is ready.\nexport const KeymapReady = createTimer('KeymapReady')\n\n/// The keymap plugin.\n/// This plugin will create a keymap manager.\n///\n/// This plugin will wait for the schema plugin.\nexport const keymap: MilkdownPlugin = (ctx) => {\n  const km = new KeymapManager()\n  km.setCtx(ctx)\n  ctx\n    .inject(keymapCtx, km)\n    .inject(keymapTimerCtx, [SchemaReady])\n    .record(KeymapReady)\n\n  return async () => {\n    await ctx.waitTimers(keymapTimerCtx)\n\n    ctx.done(KeymapReady)\n\n    return () => {\n      ctx.remove(keymapCtx).remove(keymapTimerCtx).clearTimer(KeymapReady)\n    }\n  }\n}\n","import type { MilkdownPlugin, TimerType } from '@milkdown/ctx'\nimport type { Parser } from '@milkdown/transformer'\n\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport { ctxCallOutOfScope } from '@milkdown/exception'\nimport { ParserState } from '@milkdown/transformer'\n\nimport { withMeta } from '../__internal__'\nimport { remarkCtx } from './atoms'\nimport { SchemaReady, schemaCtx } from './schema'\n\n/// The timer which will be resolved when the parser plugin is ready.\nexport const ParserReady = createTimer('ParserReady')\n\nconst outOfScope = (() => {\n  throw ctxCallOutOfScope()\n}) as Parser\n\n/// A slice which contains the parser.\nexport const parserCtx = createSlice(outOfScope, 'parser')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[SchemaReady]`.\nexport const parserTimerCtx = createSlice([] as TimerType[], 'parserTimer')\n\n/// The parser plugin.\n/// This plugin will create a parser.\n///\n/// This plugin will wait for the schema plugin.\nexport const parser: MilkdownPlugin = (ctx) => {\n  ctx\n    .inject(parserCtx, outOfScope)\n    .inject(parserTimerCtx, [SchemaReady])\n    .record(ParserReady)\n\n  return async () => {\n    await ctx.waitTimers(parserTimerCtx)\n    const remark = ctx.get(remarkCtx)\n    const schema = ctx.get(schemaCtx)\n\n    ctx.set(parserCtx, ParserState.create(schema, remark))\n    ctx.done(ParserReady)\n    return () => {\n      ctx.remove(parserCtx).remove(parserTimerCtx).clearTimer(ParserReady)\n    }\n  }\n}\n\nwithMeta(parser, {\n  displayName: 'Parser',\n})\n","import type { MilkdownPlugin, TimerType } from '@milkdown/ctx'\nimport type { Serializer } from '@milkdown/transformer'\n\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport { ctxCallOutOfScope } from '@milkdown/exception'\nimport { SerializerState } from '@milkdown/transformer'\n\nimport { withMeta } from '../__internal__'\nimport { remarkCtx } from './atoms'\nimport { SchemaReady, schemaCtx } from './schema'\n\n/// The timer which will be resolved when the serializer plugin is ready.\nexport const SerializerReady = createTimer('SerializerReady')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[SchemaReady]`.\nexport const serializerTimerCtx = createSlice(\n  [] as TimerType[],\n  'serializerTimer'\n)\n\nconst outOfScope = (() => {\n  throw ctxCallOutOfScope()\n}) as Serializer\n\n/// A slice which contains the serializer.\nexport const serializerCtx = createSlice<Serializer, 'serializer'>(\n  outOfScope,\n  'serializer'\n)\n\n/// The serializer plugin.\n/// This plugin will create a serializer.\n///\n/// This plugin will wait for the schema plugin.\nexport const serializer: MilkdownPlugin = (ctx) => {\n  ctx\n    .inject(serializerCtx, outOfScope)\n    .inject(serializerTimerCtx, [SchemaReady])\n    .record(SerializerReady)\n\n  return async () => {\n    await ctx.waitTimers(serializerTimerCtx)\n    const remark = ctx.get(remarkCtx)\n    const schema = ctx.get(schemaCtx)\n\n    ctx.set(serializerCtx, SerializerState.create(schema, remark))\n    ctx.done(SerializerReady)\n\n    return () => {\n      ctx\n        .remove(serializerCtx)\n        .remove(serializerTimerCtx)\n        .clearTimer(SerializerReady)\n    }\n  }\n}\n\nwithMeta(serializer, {\n  displayName: 'Serializer',\n})\n","import type { MilkdownPlugin, TimerType } from '@milkdown/ctx'\nimport type { Schema } from '@milkdown/prose/model'\nimport type { JSONRecord, Parser } from '@milkdown/transformer'\n\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport { docTypeError } from '@milkdown/exception'\nimport { customInputRules as createInputRules } from '@milkdown/prose'\nimport { keymap as createKeymap } from '@milkdown/prose/keymap'\nimport { DOMParser, Node } from '@milkdown/prose/model'\nimport { EditorState, Plugin, PluginKey } from '@milkdown/prose/state'\n\nimport { withMeta } from '../__internal__'\nimport { editorStateCtx, inputRulesCtx, prosePluginsCtx } from './atoms'\nimport { CommandsReady } from './commands'\nimport { keymapCtx, KeymapReady } from './keymap'\nimport { ParserReady, parserCtx } from './parser'\nimport { schemaCtx } from './schema'\nimport { SerializerReady } from './serializer'\n\n/// @internal\nexport type DefaultValue =\n  | string\n  | { type: 'html'; dom: HTMLElement }\n  | { type: 'json'; value: JSONRecord }\ntype StateOptions = Parameters<typeof EditorState.create>[0]\ntype StateOptionsOverride = (prev: StateOptions) => StateOptions\n\n/// A slice which contains the default value of the editor.\n/// Can be markdown string, html string or json.\nexport const defaultValueCtx = createSlice('' as DefaultValue, 'defaultValue')\n\n/// A slice which contains the options which is used to create the editor state.\nexport const editorStateOptionsCtx = createSlice<StateOptionsOverride>(\n  (x) => x,\n  'stateOptions'\n)\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[ParserReady, SerializerReady, CommandsReady]`.\nexport const editorStateTimerCtx = createSlice(\n  [] as TimerType[],\n  'editorStateTimer'\n)\n\n/// The timer which will be resolved when the editor state plugin is ready.\nexport const EditorStateReady = createTimer('EditorStateReady')\n\n/// @internal\nexport function getDoc(\n  defaultValue: DefaultValue,\n  parser: Parser,\n  schema: Schema\n) {\n  if (typeof defaultValue === 'string') return parser(defaultValue)\n\n  if (defaultValue.type === 'html')\n    return DOMParser.fromSchema(schema).parse(defaultValue.dom)\n\n  if (defaultValue.type === 'json')\n    return Node.fromJSON(schema, defaultValue.value)\n\n  throw docTypeError(defaultValue)\n}\n\nconst key = new PluginKey('MILKDOWN_STATE_TRACKER')\n\n/// The editor state plugin.\n/// This plugin will create a prosemirror editor state.\n///\n/// This plugin will wait for the parser plugin, serializer plugin and commands plugin.\nexport const editorState: MilkdownPlugin = (ctx) => {\n  ctx\n    .inject(defaultValueCtx, '')\n    .inject(editorStateCtx, {} as EditorState)\n    .inject(editorStateOptionsCtx, (x) => x)\n    .inject(editorStateTimerCtx, [\n      ParserReady,\n      SerializerReady,\n      CommandsReady,\n      KeymapReady,\n    ])\n    .record(EditorStateReady)\n\n  return async () => {\n    await ctx.waitTimers(editorStateTimerCtx)\n\n    const schema = ctx.get(schemaCtx)\n    const parser = ctx.get(parserCtx)\n    const rules = ctx.get(inputRulesCtx)\n    const optionsOverride = ctx.get(editorStateOptionsCtx)\n    const prosePlugins = ctx.get(prosePluginsCtx)\n    const defaultValue = ctx.get(defaultValueCtx)\n    const doc = getDoc(defaultValue, parser, schema)\n    const km = ctx.get(keymapCtx)\n    const disposeBaseKeymap = km.addBaseKeymap()\n\n    const plugins = [\n      ...prosePlugins,\n      new Plugin({\n        key,\n        state: {\n          init: () => {\n            // do nothing\n          },\n          apply: (_tr, _value, _oldState, newState) => {\n            ctx.set(editorStateCtx, newState)\n          },\n        },\n      }),\n      createInputRules({ rules }),\n      createKeymap(km.build()),\n    ]\n\n    ctx.set(prosePluginsCtx, plugins)\n\n    const options = optionsOverride({\n      schema,\n      doc,\n      plugins,\n    })\n\n    const state = EditorState.create(options)\n    ctx.set(editorStateCtx, state)\n    ctx.done(EditorStateReady)\n\n    return () => {\n      disposeBaseKeymap()\n      ctx\n        .remove(defaultValueCtx)\n        .remove(editorStateCtx)\n        .remove(editorStateOptionsCtx)\n        .remove(editorStateTimerCtx)\n        .clearTimer(EditorStateReady)\n    }\n  }\n}\n\nwithMeta(editorState, {\n  displayName: 'EditorState',\n})\n","import type { Slice } from '@milkdown/prose/model'\nimport type { EditorView } from '@milkdown/prose/view'\n\nimport { createSlice, createTimer, type MilkdownPlugin } from '@milkdown/ctx'\n\nimport { withMeta } from '../__internal__'\nimport { SchemaReady } from './schema'\n\n/// A paste rule function which takes a slice and returns a new slice.\nexport type PasteRule = {\n  /// The function to run the paste rule.\n  run: (slice: Slice, view: EditorView, isPlainText: boolean) => Slice\n  /// The priority of the paste rule. Higher priority rules will be run first. Default is 50.\n  priority?: number\n}\n\n/// A slice which contains the paste rules.\nexport const pasteRulesCtx = createSlice([] as PasteRule[], 'pasteRule')\n\n/// A slice which stores timers that need to be waited for before starting to run the paste rule plugin.\n/// By default, it's `[SchemaReady]`.\nexport const pasteRulesTimerCtx = createSlice([SchemaReady], 'pasteRuleTimer')\n\n/// The timer which will be resolved when the paste rule plugin is ready.\nexport const PasteRulesReady = createTimer('PasteRuleReady')\n\n/// The paste rule plugin.\n/// This plugin will collect the paste rules to the editor view.\n///\n/// This plugin will wait for the schema plugin.\nexport const pasteRule: MilkdownPlugin = (ctx) => {\n  ctx\n    .inject(pasteRulesCtx, [])\n    .inject(pasteRulesTimerCtx, [SchemaReady])\n    .record(PasteRulesReady)\n\n  return async () => {\n    await ctx.waitTimers(pasteRulesTimerCtx)\n\n    ctx.done(PasteRulesReady)\n\n    return () => {\n      ctx\n        .remove(pasteRulesCtx)\n        .remove(pasteRulesTimerCtx)\n        .clearTimer(PasteRulesReady)\n    }\n  }\n}\n\nwithMeta(pasteRule, {\n  displayName: 'PasteRule',\n})\n","import type { Ctx, MilkdownPlugin, TimerType } from '@milkdown/ctx'\nimport type { DirectEditorProps } from '@milkdown/prose/view'\n\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport { EditorView } from '@milkdown/prose/view'\n\nimport { withMeta } from '../__internal__'\nimport {\n  editorStateCtx,\n  editorViewCtx,\n  markViewCtx,\n  nodeViewCtx,\n  prosePluginsCtx,\n} from './atoms'\nimport { EditorStateReady } from './editor-state'\nimport { InitReady } from './init'\nimport { pasteRulesCtx, PasteRulesReady } from './paste-rule'\n\ntype EditorOptions = Omit<DirectEditorProps, 'state'>\n\ntype RootType = Node | undefined | null | string\n\n/// The timer which will be resolved when the editor view plugin is ready.\nexport const EditorViewReady = createTimer('EditorViewReady')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[EditorStateReady]`.\nexport const editorViewTimerCtx = createSlice(\n  [] as TimerType[],\n  'editorViewTimer'\n)\n\n/// A slice which contains the editor view options which will be passed to the editor view.\nexport const editorViewOptionsCtx = createSlice(\n  {} as Partial<EditorOptions>,\n  'editorViewOptions'\n)\n\n/// A slice which contains the value to get the root element.\n/// Can be a selector string, a node or null.\n/// If it's null, the editor will be created in the body.\nexport const rootCtx = createSlice(null as RootType, 'root')\n\n/// A slice which contains the actually root element.\nexport const rootDOMCtx = createSlice(null as unknown as HTMLElement, 'rootDOM')\n\n/// A slice which contains the root element attributes.\n/// You can add attributes to the root element by this slice.\nexport const rootAttrsCtx = createSlice(\n  {} as Record<string, string>,\n  'rootAttrs'\n)\n\nfunction createViewContainer(root: Node, ctx: Ctx) {\n  const container = document.createElement('div')\n  container.className = 'milkdown'\n  root.appendChild(container)\n  ctx.set(rootDOMCtx, container)\n\n  const attrs = ctx.get(rootAttrsCtx)\n  Object.entries(attrs).forEach(([key, value]) =>\n    container.setAttribute(key, value)\n  )\n\n  return container\n}\n\nfunction prepareViewDom(dom: Element) {\n  dom.classList.add('editor')\n  dom.setAttribute('role', 'textbox')\n}\n\nconst key = new PluginKey('MILKDOWN_VIEW_CLEAR')\n\n/// The editor view plugin.\n/// This plugin will create an editor view.\n///\n/// This plugin will wait for the editor state plugin.\nexport const editorView: MilkdownPlugin = (ctx) => {\n  ctx\n    .inject(rootCtx, document.body)\n    .inject(editorViewCtx, {} as EditorView)\n    .inject(editorViewOptionsCtx, {})\n    .inject(rootDOMCtx, null as unknown as HTMLElement)\n    .inject(rootAttrsCtx, {})\n    .inject(editorViewTimerCtx, [EditorStateReady, PasteRulesReady])\n    .record(EditorViewReady)\n\n  return async () => {\n    await ctx.wait(InitReady)\n\n    const root = ctx.get(rootCtx) || document.body\n    const el = typeof root === 'string' ? document.querySelector(root) : root\n\n    ctx.update(prosePluginsCtx, (xs) => [\n      new Plugin({\n        key,\n        view: (editorView) => {\n          const container = el ? createViewContainer(el, ctx) : undefined\n\n          const handleDOM = () => {\n            if (container && el) {\n              const editor = editorView.dom\n              el.replaceChild(container, editor)\n              container.appendChild(editor)\n            }\n          }\n          handleDOM()\n          return {\n            destroy: () => {\n              if (container?.parentNode)\n                container?.parentNode.replaceChild(editorView.dom, container)\n\n              container?.remove()\n            },\n          }\n        },\n      }),\n      ...xs,\n    ])\n\n    await ctx.waitTimers(editorViewTimerCtx)\n\n    const state = ctx.get(editorStateCtx)\n    const options = ctx.get(editorViewOptionsCtx)\n    const nodeViews = Object.fromEntries(ctx.get(nodeViewCtx))\n    const markViews = Object.fromEntries(ctx.get(markViewCtx))\n    const view = new EditorView(el as Node, {\n      state,\n      nodeViews,\n      markViews,\n      transformPasted: (slice, view, isPlainText) => {\n        ctx\n          .get(pasteRulesCtx)\n          .sort((a, b) => (b.priority ?? 50) - (a.priority ?? 50))\n          .map((rule) => rule.run)\n          .forEach((runner) => {\n            slice = runner(slice, view, isPlainText)\n          })\n\n        return slice\n      },\n      ...options,\n    })\n    prepareViewDom(view.dom)\n    ctx.set(editorViewCtx, view)\n    ctx.done(EditorViewReady)\n\n    return () => {\n      view?.destroy()\n      ctx\n        .remove(rootCtx)\n        .remove(editorViewCtx)\n        .remove(editorViewOptionsCtx)\n        .remove(rootDOMCtx)\n        .remove(rootAttrsCtx)\n        .remove(editorViewTimerCtx)\n        .clearTimer(EditorViewReady)\n    }\n  }\n}\n\nwithMeta(editorView, {\n  displayName: 'EditorView',\n})\n","import type { CtxRunner, MilkdownPlugin, Telemetry } from '@milkdown/ctx'\n\nimport { Clock, Container, Ctx } from '@milkdown/ctx'\n\nimport type { Config } from '../internal-plugin'\n\nimport {\n  commands,\n  config,\n  editorState,\n  editorView,\n  init,\n  keymap,\n  parser,\n  pasteRule,\n  schema,\n  serializer,\n} from '../internal-plugin'\n\n/// The status of the editor.\nexport enum EditorStatus {\n  /// The editor is not initialized.\n  Idle = 'Idle',\n  /// The editor is creating.\n  OnCreate = 'OnCreate',\n  /// The editor has been created and ready to use.\n  Created = 'Created',\n  /// The editor is destroying.\n  OnDestroy = 'OnDestroy',\n  /// The editor has been destroyed.\n  Destroyed = 'Destroyed',\n}\n\n/// Type for the callback called when editor status changed.\nexport type OnStatusChange = (status: EditorStatus) => void\n\ntype EditorPluginStore = Map<\n  MilkdownPlugin,\n  {\n    ctx: Ctx | undefined\n    handler: CtxRunner | undefined\n    cleanup: ReturnType<CtxRunner>\n  }\n>\n\n/// The milkdown editor class.\nexport class Editor {\n  /// Create a new editor instance.\n  static make() {\n    return new Editor()\n  }\n\n  /// @internal\n  #enableInspector = false\n  /// @internal\n  #status = EditorStatus.Idle\n  /// @internal\n  #configureList: Config[] = []\n  /// @internal\n  #onStatusChange: OnStatusChange = () => undefined\n\n  /// @internal\n  readonly #container = new Container()\n  /// @internal\n  readonly #clock = new Clock()\n\n  /// @internal\n  readonly #usrPluginStore: EditorPluginStore = new Map()\n\n  /// @internal\n  readonly #sysPluginStore: EditorPluginStore = new Map()\n\n  /// @internal\n  readonly #ctx = new Ctx(this.#container, this.#clock)\n\n  /// @internal\n  readonly #loadInternal = () => {\n    const configPlugin = config(async (ctx) => {\n      await Promise.all(\n        this.#configureList.map((fn) => Promise.resolve(fn(ctx)))\n      )\n    })\n    const internalPlugins = [\n      schema,\n      parser,\n      serializer,\n      commands,\n      keymap,\n      pasteRule,\n      editorState,\n      editorView,\n      init(this),\n      configPlugin,\n    ]\n    this.#prepare(internalPlugins, this.#sysPluginStore)\n  }\n\n  /// @internal\n  readonly #prepare = (plugins: MilkdownPlugin[], store: EditorPluginStore) => {\n    plugins.forEach((plugin) => {\n      const ctx = this.#ctx.produce(\n        this.#enableInspector ? plugin.meta : undefined\n      )\n      const handler = plugin(ctx)\n      store.set(plugin, { ctx, handler, cleanup: undefined })\n    })\n  }\n\n  /// @internal\n  readonly #cleanup = (plugins: MilkdownPlugin[], remove = false) => {\n    return Promise.all(\n      [plugins].flat().map(async (plugin) => {\n        const loader = this.#usrPluginStore.get(plugin)\n        const cleanup = loader?.cleanup\n        if (remove) this.#usrPluginStore.delete(plugin)\n        else\n          this.#usrPluginStore.set(plugin, {\n            ctx: undefined,\n            handler: undefined,\n            cleanup: undefined,\n          })\n\n        if (typeof cleanup === 'function') return cleanup()\n\n        return cleanup\n      })\n    )\n  }\n\n  /// @internal\n  readonly #cleanupInternal = async () => {\n    await Promise.all(\n      [...this.#sysPluginStore.entries()].map(async ([_, { cleanup }]) => {\n        if (typeof cleanup === 'function') return cleanup()\n\n        return cleanup\n      })\n    )\n    this.#sysPluginStore.clear()\n  }\n\n  /// @internal\n  readonly #setStatus = (status: EditorStatus) => {\n    this.#status = status\n    this.#onStatusChange(status)\n  }\n\n  /// @internal\n  readonly #loadPluginInStore = (store: EditorPluginStore) => {\n    return [...store.entries()].map(async ([key, loader]) => {\n      const { ctx, handler } = loader\n      if (!handler) return\n\n      const cleanup = await handler()\n\n      store.set(key, { ctx, handler, cleanup })\n    })\n  }\n\n  /// Get the ctx of the editor.\n  get ctx() {\n    return this.#ctx\n  }\n\n  /// Get the status of the editor.\n  get status() {\n    return this.#status\n  }\n\n  /// Enable the inspector for the editor.\n  /// You can also pass `false` to disable the inspector.\n  readonly enableInspector = (enable = true) => {\n    this.#enableInspector = enable\n\n    return this\n  }\n\n  /// Subscribe to the status change event for the editor.\n  /// The new subscription will replace the old one.\n  readonly onStatusChange = (onChange: OnStatusChange) => {\n    this.#onStatusChange = onChange\n    return this\n  }\n\n  /// Add a config for the editor.\n  readonly config = (configure: Config) => {\n    this.#configureList.push(configure)\n    return this\n  }\n\n  /// Remove a config for the editor.\n  readonly removeConfig = (configure: Config) => {\n    this.#configureList = this.#configureList.filter((x) => x !== configure)\n    return this\n  }\n\n  /// Use a plugin or a list of plugins for the editor.\n  readonly use = (plugins: MilkdownPlugin | MilkdownPlugin[]) => {\n    const _plugins = [plugins].flat()\n    _plugins.flat().forEach((plugin) => {\n      this.#usrPluginStore.set(plugin, {\n        ctx: undefined,\n        handler: undefined,\n        cleanup: undefined,\n      })\n    })\n\n    if (this.#status === EditorStatus.Created)\n      this.#prepare(_plugins, this.#usrPluginStore)\n\n    return this\n  }\n\n  /// Remove a plugin or a list of plugins from the editor.\n  readonly remove = async (\n    plugins: MilkdownPlugin | MilkdownPlugin[]\n  ): Promise<Editor> => {\n    if (this.#status === EditorStatus.OnCreate) {\n      console.warn(\n        '[Milkdown]: You are trying to remove plugins when the editor is creating, this is not recommended, please check your code.'\n      )\n      return new Promise((resolve) => {\n        setTimeout(() => {\n          resolve(this.remove(plugins))\n        }, 50)\n      })\n    }\n\n    await this.#cleanup([plugins].flat(), true)\n    return this\n  }\n\n  /// Create the editor with current config and plugins.\n  /// If the editor is already created, it will be recreated.\n  readonly create = async (): Promise<Editor> => {\n    if (this.#status === EditorStatus.OnCreate) return this\n\n    if (this.#status === EditorStatus.Created) await this.destroy()\n\n    this.#setStatus(EditorStatus.OnCreate)\n\n    this.#loadInternal()\n    this.#prepare([...this.#usrPluginStore.keys()], this.#usrPluginStore)\n\n    await Promise.all(\n      [\n        this.#loadPluginInStore(this.#sysPluginStore),\n        this.#loadPluginInStore(this.#usrPluginStore),\n      ].flat()\n    )\n\n    this.#setStatus(EditorStatus.Created)\n    return this\n  }\n\n  /// Destroy the editor.\n  /// If you want to clear all plugins, set `clearPlugins` to `true`.\n  readonly destroy = async (clearPlugins = false): Promise<Editor> => {\n    if (\n      this.#status === EditorStatus.Destroyed ||\n      this.#status === EditorStatus.OnDestroy\n    )\n      return this\n\n    if (this.#status === EditorStatus.OnCreate) {\n      return new Promise((resolve) => {\n        setTimeout(() => {\n          resolve(this.destroy(clearPlugins))\n        }, 50)\n      })\n    }\n\n    if (clearPlugins) this.#configureList = []\n\n    this.#setStatus(EditorStatus.OnDestroy)\n    await this.#cleanup([...this.#usrPluginStore.keys()], clearPlugins)\n    await this.#cleanupInternal()\n\n    this.#setStatus(EditorStatus.Destroyed)\n    return this\n  }\n\n  /// Call an action with the ctx of the editor.\n  /// This method should be used after the editor is created.\n  readonly action = <T>(action: (ctx: Ctx) => T) => action(this.#ctx)\n\n  /// Get inspections of plugins in editor.\n  /// Make sure you have enabled inspector by `editor.enableInspector()` before calling this method.\n  readonly inspect = (): Telemetry[] => {\n    if (!this.#enableInspector) {\n      console.warn(\n        '[Milkdown]: You are trying to collect inspection when inspector is disabled, please enable inspector by `editor.enableInspector()` first.'\n      )\n      return []\n    }\n    return [...this.#sysPluginStore.values(), ...this.#usrPluginStore.values()]\n      .map(({ ctx }) => ctx?.inspector?.read())\n      .filter((x): x is Telemetry => Boolean(x))\n  }\n}\n"],"names":["key","schema","commands","keymap","outOfScope","parser","createInputRules","createKeymap","editorView","view","EditorStatus"],"mappings":"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"}