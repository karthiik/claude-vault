{"version":3,"file":"index.js","sources":["../src/context/container.ts","../src/context/slice.ts","../src/inspector/inspector.ts","../src/plugin/ctx.ts","../src/timer/clock.ts","../src/timer/timer.ts"],"sourcesContent":["import { contextNotFound } from '@milkdown/exception'\n\nimport type { Slice, SliceType } from './slice'\n\n/// @internal\nexport type SliceMap = Map<symbol, Slice>\n\n/// Container is a map of slices.\nexport class Container {\n  /// @internal\n  sliceMap: SliceMap = new Map()\n\n  /// Get a slice from the container by slice type or slice name.\n  get = <T, N extends string = string>(\n    slice: SliceType<T, N> | N\n  ): Slice<T, N> => {\n    const context =\n      typeof slice === 'string'\n        ? [...this.sliceMap.values()].find((x) => x.type.name === slice)\n        : this.sliceMap.get(slice.id)\n\n    if (!context) {\n      const name = typeof slice === 'string' ? slice : slice.name\n      throw contextNotFound(name)\n    }\n    return context as Slice<T, N>\n  }\n\n  /// Remove a slice from the container by slice type or slice name.\n  remove = <T, N extends string = string>(slice: SliceType<T, N> | N): void => {\n    const context =\n      typeof slice === 'string'\n        ? [...this.sliceMap.values()].find((x) => x.type.name === slice)\n        : this.sliceMap.get(slice.id)\n\n    if (!context) return\n\n    this.sliceMap.delete(context.type.id)\n  }\n\n  /// Check if the container has a slice by slice type or slice name.\n  has = <T, N extends string = string>(slice: SliceType<T, N> | N): boolean => {\n    if (typeof slice === 'string')\n      return [...this.sliceMap.values()].some((x) => x.type.name === slice)\n\n    return this.sliceMap.has(slice.id)\n  }\n}\n","import { ctxCallOutOfScope } from '@milkdown/exception'\n\nimport type { SliceMap } from './container'\n\n/// Slice is a value of slice type.\nexport class Slice<T = any, N extends string = string> {\n  /// The type of the slice.\n  readonly type: SliceType<T, N>\n\n  /// @internal\n  #watchers: Array<(value: T) => unknown> = []\n\n  /// @internal\n  #value: T\n\n  /// @internal\n  #emit = () => {\n    this.#watchers.forEach((watcher) => watcher(this.#value))\n  }\n\n  /// @internal\n  constructor(container: SliceMap, value: T, type: SliceType<T, N>) {\n    this.type = type\n    this.#value = value\n    container.set(type.id, this)\n  }\n\n  /// Add a watcher for changes in the slice.\n  /// Returns a function to remove the watcher.\n  on(watcher: (value: T) => unknown) {\n    this.#watchers.push(watcher)\n    return () => {\n      this.#watchers = this.#watchers.filter((w) => w !== watcher)\n    }\n  }\n\n  /// Add a one-time watcher for changes in the slice.\n  /// The watcher will be removed after it is called.\n  /// Returns a function to remove the watcher.\n  once(watcher: (value: T) => unknown) {\n    const off = this.on((value) => {\n      watcher(value)\n      off()\n    })\n    return off\n  }\n\n  /// Remove a watcher.\n  off(watcher: (value: T) => unknown) {\n    this.#watchers = this.#watchers.filter((w) => w !== watcher)\n  }\n\n  /// Remove all watchers.\n  offAll() {\n    this.#watchers = []\n  }\n\n  /// Set the value of the slice.\n  set = (value: T) => {\n    this.#value = value\n    this.#emit()\n  }\n\n  /// Get the value of the slice.\n  get = () => this.#value\n\n  /// Update the value of the slice with a callback.\n  update = (updater: (prev: T) => T) => {\n    this.#value = updater(this.#value)\n    this.#emit()\n  }\n}\n\n/// Slice type can be used to create slices in different containers.\nexport class SliceType<T = any, N extends string = string> {\n  /// The unique id of the slice type.\n  readonly id: symbol\n  /// The name of the slice type.\n  readonly name: N\n  /// @internal\n  readonly _typeInfo: () => T\n  /// @internal\n  readonly _defaultValue: T\n\n  /// Create a slice type with a default value and a name.\n  /// The name should be unique in the container.\n  constructor(value: T, name: N) {\n    this.id = Symbol(`Context-${name}`)\n    this.name = name\n    this._defaultValue = value\n    this._typeInfo = (): T => {\n      throw ctxCallOutOfScope()\n    }\n  }\n\n  /// Create a slice with a container.\n  /// You can also pass a value to override the default value.\n  create(container: SliceMap, value: T = this._defaultValue): Slice<T, N> {\n    return new Slice(container, value, this)\n  }\n}\n\n/// Create a slice type with a default value and a name.\n/// This is equivalent to `new SliceType(value, name)`.\nexport const createSlice = <T = any, N extends string = string>(\n  value: T,\n  name: N\n) => new SliceType(value, name)\n","import type { Container, SliceType } from '../context'\nimport type { Clock, TimerStatus, TimerType } from '../timer'\nimport type { Meta } from './meta'\n\nexport interface Telemetry {\n  metadata: Meta\n  injectedSlices: { name: string; value: unknown }[]\n  consumedSlices: { name: string; value: unknown }[]\n  recordedTimers: { name: string; duration: number; status: TimerStatus }[]\n  waitTimers: { name: string; duration: number; status: TimerStatus }[]\n}\n\n/// The inspector object that is used to inspect the runtime environment of a ctx.\nexport class Inspector {\n  /// @internal\n  readonly #meta: Meta\n\n  /// @internal\n  readonly #container: Container\n\n  /// @internal\n  readonly #clock: Clock\n\n  /// @internal\n  readonly #injectedSlices: Set<SliceType | string> = new Set()\n\n  /// @internal\n  readonly #consumedSlices: Set<SliceType | string> = new Set()\n\n  /// @internal\n  readonly #recordedTimers: Map<\n    TimerType,\n    { duration: number; start: number }\n  > = new Map()\n\n  /// @internal\n  readonly #waitTimers: Map<TimerType, { duration: number }> = new Map()\n\n  /// Create an inspector with container, clock and metadata.\n  constructor(container: Container, clock: Clock, meta: Meta) {\n    this.#container = container\n    this.#clock = clock\n    this.#meta = meta\n  }\n\n  /// Read the runtime telemetry as an object of the ctx.\n  read = (): Telemetry => {\n    return {\n      metadata: this.#meta,\n      injectedSlices: [...this.#injectedSlices].map((slice) => ({\n        name: typeof slice === 'string' ? slice : slice.name,\n        value: this.#getSlice(slice),\n      })),\n      consumedSlices: [...this.#consumedSlices].map((slice) => ({\n        name: typeof slice === 'string' ? slice : slice.name,\n        value: this.#getSlice(slice),\n      })),\n      recordedTimers: [...this.#recordedTimers].map(\n        ([timer, { duration }]) => ({\n          name: timer.name,\n          duration,\n          status: this.#getTimer(timer),\n        })\n      ),\n      waitTimers: [...this.#waitTimers].map(([timer, { duration }]) => ({\n        name: timer.name,\n        duration,\n        status: this.#getTimer(timer),\n      })),\n    }\n  }\n\n  /// @internal\n  readonly onRecord = (timerType: TimerType) => {\n    this.#recordedTimers.set(timerType, { start: Date.now(), duration: 0 })\n  }\n\n  /// @internal\n  readonly onClear = (timerType: TimerType) => {\n    this.#recordedTimers.delete(timerType)\n  }\n\n  /// @internal\n  readonly onDone = (timerType: TimerType) => {\n    const timer = this.#recordedTimers.get(timerType)\n    if (!timer) return\n    timer.duration = Date.now() - timer.start\n  }\n\n  /// @internal\n  readonly onWait = (timerType: TimerType, promise: Promise<void>) => {\n    const start = Date.now()\n    promise\n      .finally(() => {\n        this.#waitTimers.set(timerType, { duration: Date.now() - start })\n      })\n      .catch(console.error)\n  }\n\n  /// @internal\n  readonly onInject = (sliceType: SliceType | string) => {\n    this.#injectedSlices.add(sliceType)\n  }\n\n  /// @internal\n  readonly onRemove = (sliceType: SliceType | string) => {\n    this.#injectedSlices.delete(sliceType)\n  }\n\n  /// @internal\n  readonly onUse = (sliceType: SliceType | string) => {\n    this.#consumedSlices.add(sliceType)\n  }\n\n  /// @internal\n  #getSlice = (sliceType: SliceType | string) => {\n    return this.#container.get(sliceType).get()\n  }\n\n  /// @internal\n  #getTimer = (timerType: TimerType) => {\n    return this.#clock.get(timerType).status\n  }\n}\n","import type { Container, Slice, SliceType } from '../context'\nimport type { Meta } from '../inspector'\nimport type { Clock, TimerType } from '../timer'\n\nimport { Inspector } from '../inspector'\n\n/// The ctx object that can be accessed in plugin and action.\nexport class Ctx {\n  /// @internal\n  readonly #container: Container\n  /// @internal\n  readonly #clock: Clock\n  /// @internal\n  readonly #meta?: Meta\n  /// @internal\n  readonly #inspector?: Inspector\n\n  /// Create a ctx object with container and clock.\n  constructor(container: Container, clock: Clock, meta?: Meta) {\n    this.#container = container\n    this.#clock = clock\n    this.#meta = meta\n    if (meta) this.#inspector = new Inspector(container, clock, meta)\n  }\n\n  /// Get metadata of the ctx.\n  get meta() {\n    return this.#meta\n  }\n\n  /// Get the inspector of the ctx.\n  get inspector() {\n    return this.#inspector\n  }\n\n  /// Produce a new ctx with metadata.\n  /// The new ctx will link to the same container and clock with the current ctx.\n  /// If the metadata is empty, it will return the current ctx.\n  readonly produce = (meta?: Meta) => {\n    if (meta && Object.keys(meta).length)\n      return new Ctx(this.#container, this.#clock, { ...meta })\n\n    return this\n  }\n\n  /// Add a slice into the ctx.\n  readonly inject = <T>(sliceType: SliceType<T>, value?: T) => {\n    const slice = sliceType.create(this.#container.sliceMap)\n    if (value != null) slice.set(value)\n\n    this.#inspector?.onInject(sliceType)\n\n    return this\n  }\n\n  /// Remove a slice from the ctx.\n  readonly remove = <T, N extends string = string>(\n    sliceType: SliceType<T, N> | N\n  ) => {\n    this.#container.remove(sliceType)\n    this.#inspector?.onRemove(sliceType)\n    return this\n  }\n\n  /// Add a timer into the ctx.\n  readonly record = (timerType: TimerType) => {\n    timerType.create(this.#clock.store)\n    this.#inspector?.onRecord(timerType)\n    return this\n  }\n\n  /// Remove a timer from the ctx.\n  readonly clearTimer = (timerType: TimerType) => {\n    this.#clock.remove(timerType)\n    this.#inspector?.onClear(timerType)\n    return this\n  }\n\n  /// Check if the ctx has a slice.\n  readonly isInjected = <T, N extends string = string>(\n    sliceType: SliceType<T, N> | N\n  ) => this.#container.has(sliceType)\n\n  /// Check if the ctx has a timer.\n  readonly isRecorded = (timerType: TimerType) => this.#clock.has(timerType)\n\n  /// Get a slice from the ctx.\n  readonly use = <T, N extends string = string>(\n    sliceType: SliceType<T, N> | N\n  ): Slice<T, N> => {\n    this.#inspector?.onUse(sliceType)\n    return this.#container.get(sliceType)\n  }\n\n  /// Get a slice value from the ctx.\n  readonly get = <T, N extends string>(sliceType: SliceType<T, N> | N) =>\n    this.use(sliceType).get()\n\n  /// Get a slice value from the ctx.\n  readonly set = <T, N extends string>(\n    sliceType: SliceType<T, N> | N,\n    value: T\n  ) => this.use(sliceType).set(value)\n\n  /// Update a slice value from the ctx by a callback.\n  readonly update = <T, N extends string>(\n    sliceType: SliceType<T, N> | N,\n    updater: (prev: T) => T\n  ) => this.use(sliceType).update(updater)\n\n  /// Get a timer from the ctx.\n  readonly timer = (timer: TimerType) => this.#clock.get(timer)\n\n  /// Resolve a timer from the ctx.\n  readonly done = (timer: TimerType) => {\n    this.timer(timer).done()\n    this.#inspector?.onDone(timer)\n  }\n\n  /// Start a timer from the ctx.\n  readonly wait = (timer: TimerType) => {\n    const promise = this.timer(timer).start()\n    this.#inspector?.onWait(timer, promise)\n    return promise\n  }\n\n  /// Start a list of timers from the ctx, the list is stored in a slice in the ctx.\n  /// This is equivalent to\n  ///\n  /// ```typescript\n  /// Promise.all(ctx.get(slice).map(x => ctx.wait(x))).\n  /// ```\n  readonly waitTimers = async (slice: SliceType<TimerType[]>) => {\n    await Promise.all(this.get(slice).map((x) => this.wait(x)))\n  }\n}\n","import { timerNotFound } from '@milkdown/exception'\n\nimport type { Timer, TimerType } from './timer'\n\n/// @internal\nexport type TimerMap = Map<symbol, Timer>\n\n/// Container is a map of timers.\nexport class Clock {\n  /// @internal\n  readonly store: TimerMap = new Map()\n\n  /// Get a timer from the clock by timer type.\n  get = (timer: TimerType) => {\n    const meta = this.store.get(timer.id)\n    if (!meta) throw timerNotFound(timer.name)\n    return meta\n  }\n\n  /// Remove a timer from the clock by timer type.\n  remove = (timer: TimerType) => {\n    this.store.delete(timer.id)\n  }\n\n  // Check if the clock has a timer by timer type.\n  has = (timer: TimerType) => {\n    return this.store.has(timer.id)\n  }\n}\n","import type { TimerMap } from './clock'\n\nexport type TimerStatus = 'pending' | 'resolved' | 'rejected'\n\n/// Timer is a promise that can be resolved by calling done.\nexport class Timer {\n  /// The type of the timer.\n  readonly type: TimerType\n\n  /// @internal\n  #promise: Promise<void> | null = null\n  /// @internal\n  #listener: EventListener | null = null\n  /// @internal\n  readonly #eventUniqId: symbol\n  /// @internal\n  #status: TimerStatus = 'pending'\n\n  /// @internal\n  constructor(clock: TimerMap, type: TimerType) {\n    this.#eventUniqId = Symbol(type.name)\n    this.type = type\n    clock.set(type.id, this)\n  }\n\n  /// The status of the timer.\n  /// Can be `pending`, `resolved` or `rejected`.\n  get status() {\n    return this.#status\n  }\n\n  /// Start the timer, which will return a promise.\n  /// If the timer is already started, it will return the same promise.\n  /// If the timer is not resolved in the timeout, it will reject the promise.\n  start = () => {\n    this.#promise ??= new Promise((resolve, reject) => {\n      this.#listener = (e: Event) => {\n        if (!(e instanceof CustomEvent)) return\n\n        if (e.detail.id === this.#eventUniqId) {\n          this.#status = 'resolved'\n          this.#removeListener()\n          e.stopImmediatePropagation()\n          resolve()\n        }\n      }\n\n      this.#waitTimeout(() => {\n        if (this.#status === 'pending') this.#status = 'rejected'\n\n        this.#removeListener()\n        reject(new Error(`Timing ${this.type.name} timeout.`))\n      })\n\n      this.#status = 'pending'\n      addEventListener(this.type.name, this.#listener)\n    })\n\n    return this.#promise\n  }\n\n  /// Resolve the timer.\n  done = () => {\n    const event = new CustomEvent(this.type.name, {\n      detail: { id: this.#eventUniqId },\n    })\n    dispatchEvent(event)\n  }\n\n  /// @internal\n  #removeListener = () => {\n    if (this.#listener) removeEventListener(this.type.name, this.#listener)\n  }\n\n  /// @internal\n  #waitTimeout = (ifTimeout: () => void) => {\n    setTimeout(() => {\n      ifTimeout()\n    }, this.type.timeout)\n  }\n}\n\n/// Timer type can be used to create timers in different clocks.\nexport class TimerType {\n  /// The unique id of the timer type.\n  readonly id: symbol\n  /// The name of the timer type.\n  readonly name: string\n  /// The timeout of the timer type.\n  readonly timeout: number\n\n  /// Create a timer type with a name and a timeout.\n  /// The name should be unique in the clock.\n  constructor(name: string, timeout = 3000) {\n    this.id = Symbol(`Timer-${name}`)\n    this.name = name\n    this.timeout = timeout\n  }\n\n  /// Create a timer with a clock.\n  create = (clock: TimerMap): Timer => {\n    return new Timer(clock, this)\n  }\n}\n\n/// Create a timer type with a name and a timeout.\n/// This is equivalent to `new TimerType(name, timeout)`.\nexport const createTimer = (name: string, timeout = 3000) =>\n  new TimerType(name, timeout)\n"],"names":["value","meta"],"mappings":"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"}