{"version":3,"file":"index.js","sources":["../src/composable/utils.ts","../src/composable/$command.ts","../src/composable/$input-rule.ts","../src/composable/$paste-rule.ts","../src/composable/$mark.ts","../src/composable/$node.ts","../src/composable/$prose.ts","../src/composable/$shortcut.ts","../src/composable/$view.ts","../src/composable/$ctx.ts","../src/composable/composed/$node-schema.ts","../src/composable/composed/$mark-schema.ts","../src/composable/composed/$use-keymap.ts","../src/composable/composed/$attr.ts","../src/composable/composed/$remark.ts","../src/macro/call-command.ts","../src/macro/force-update.ts","../src/macro/get-html.ts","../src/macro/get-markdown.ts","../src/macro/insert.ts","../src/macro/outline.ts","../src/macro/replace-all.ts","../src/macro/set-attr.ts","../src/macro/markdown-to-slice.ts","../src/macro/insert-pos.ts","../src/macro/replace-range.ts","../src/pipe.ts"],"sourcesContent":["import type {\n  Cleanup,\n  Ctx,\n  MilkdownPlugin,\n  SliceType,\n  TimerType,\n} from '@milkdown/ctx'\n\nimport { createTimer } from '@milkdown/ctx'\nimport { customAlphabet } from 'nanoid'\n\n/// @internal\nexport const nanoid = customAlphabet('abcedfghicklmn', 10)\n\n/// @internal\nexport type WithTimer<T> = T & { timer: TimerType }\n\n/// @internal\nexport function addTimer<\n  T extends MilkdownPlugin,\n  PluginWithTimer extends T = WithTimer<T>,\n>(\n  runner: (\n    ctx: Ctx,\n    plugin: PluginWithTimer,\n    done: () => void\n  ) => Promise<void | Cleanup>,\n  injectTo: SliceType<TimerType[], string>,\n  timerName?: string\n): PluginWithTimer {\n  const timer = createTimer(timerName || nanoid())\n  let doneCalled = false\n\n  const plugin: MilkdownPlugin = (ctx) => {\n    ctx.record(timer)\n    ctx.update(injectTo, (x) => x.concat(timer))\n\n    return async () => {\n      const done = () => {\n        ctx.done(timer)\n        doneCalled = true\n      }\n\n      const cleanup = await runner(ctx, <PluginWithTimer>plugin, done)\n\n      if (!doneCalled) ctx.done(timer)\n\n      return () => {\n        ctx.update(injectTo, (x) => x.filter((y) => y !== timer))\n        ctx.clearTimer(timer)\n        if (cleanup) {\n          const result = cleanup()\n          if (result && 'then' in result) {\n            result.catch(console.error)\n          }\n        }\n      }\n    }\n  }\n  ;(<T & { timer: TimerType }>plugin).timer = timer\n\n  return <PluginWithTimer>plugin\n}\n","import type { Cmd, CmdKey } from '@milkdown/core'\nimport type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\n\nimport {\n  CommandsReady,\n  commandsCtx,\n  commandsTimerCtx,\n  createCmdKey,\n} from '@milkdown/core'\n\nimport { addTimer } from './utils'\n\n/// @internal\nexport type $Command<T> = MilkdownPlugin & {\n  run: (payload?: T) => boolean\n  key: CmdKey<T>\n}\n\n/// Create a command plugin. The command will be registered in the `commandsCtx` and can be called by other parts of the editor.\n/// It takes a key and a factory function. The factory function will be called when the plugin is created.\n/// The factory should return a function that will be called when the command is executed.\n/// The function should receive at **most one parameter**, which is the payload of the command.\n/// And the payload should always be **optional**.\n///\n/// ```ts\n/// import { setBlockType } from '@milkdown/prose/commands'\n///\n/// const commandPlugin = $command('SetAsHeading', (ctx) => {\n///   return (level = 1) => setBlockType(headingSchema.type(), { level });\n/// });\n/// ```\n///\n/// Additional property:\n/// - `key`: The key of the command.\n/// - `run`: The function to run the command.\n///\n/// You can use `callCommand` in `editor.action` to call the command.\n///\n/// ```ts\n/// import { callCommand } from '@milkdown/utils';\n/// const editor = Editor.make().use(/* some plugins */).use(commandPlugin).create();\n///\n/// editor.action(callCommand(commandPlugin.key, 3));\n/// ```\nexport function $command<T, K extends string>(\n  key: K,\n  cmd: (ctx: Ctx) => Cmd<T>\n): $Command<T> {\n  const cmdKey = createCmdKey<T>(key)\n\n  const plugin: MilkdownPlugin = (ctx) => async () => {\n    ;(<$Command<T>>plugin).key = cmdKey\n    await ctx.wait(CommandsReady)\n    const command = cmd(ctx)\n    ctx.get(commandsCtx).create(cmdKey, command)\n    ;(<$Command<T>>plugin).run = (payload?: T) =>\n      ctx.get(commandsCtx).call(key, payload)\n\n    return () => {\n      ctx.get(commandsCtx).remove(cmdKey)\n    }\n  }\n\n  return <$Command<T>>plugin\n}\n\n/// The async version for `$command`. You can use `await` in the factory when creating the command.\n/// ```ts\n/// const commandPlugin = $commandASync('LoadRemoteDoc', (ctx) => {\n///   return async (url = 'my-remote-api') => {\n///     const doc = await LoadRemoteDoc(url);\n///     return addDoc(doc);\n///   }\n/// });\n/// ```\n///\n/// Additional property:\n/// - `key`: The key of the command.\n/// - `run`: The function to run the command.\n/// - `timer`: The timer which will be resolved when the command is ready.\nexport function $commandAsync<T, K extends string>(\n  key: K,\n  cmd: (ctx: Ctx) => Promise<Cmd<T>>,\n  timerName?: string\n) {\n  const cmdKey = createCmdKey<T>(key)\n  return addTimer<$Command<T>>(\n    async (ctx, plugin) => {\n      await ctx.wait(CommandsReady)\n      const command = await cmd(ctx)\n      ctx.get(commandsCtx).create(cmdKey, command)\n      ;(<$Command<T>>plugin).run = (payload?: T) =>\n        ctx.get(commandsCtx).call(key, payload)\n      ;(<$Command<T>>plugin).key = cmdKey\n      return () => {\n        ctx.get(commandsCtx).remove(cmdKey)\n      }\n    },\n    commandsTimerCtx,\n    timerName\n  )\n}\n","import type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\nimport type { InputRule } from '@milkdown/prose/inputrules'\n\nimport { SchemaReady, editorStateTimerCtx, inputRulesCtx } from '@milkdown/core'\n\nimport { addTimer } from './utils'\n\n/// @internal\nexport type $InputRule = MilkdownPlugin & {\n  inputRule: InputRule\n}\n\n/// Create an input rule plugin.\n/// It takes a factory function which returns a [prosemirror input rule](https://prosemirror.net/docs/ref/#inputrules.InputRule).\n///\n/// Additional property:\n/// - `inputRule`: The prosemirror input rule created.\nexport function $inputRule(inputRule: (ctx: Ctx) => InputRule): $InputRule {\n  const plugin: MilkdownPlugin = (ctx) => async () => {\n    await ctx.wait(SchemaReady)\n    const ir = inputRule(ctx)\n    ctx.update(inputRulesCtx, (irs) => [...irs, ir])\n    ;(<$InputRule>plugin).inputRule = ir\n\n    return () => {\n      ctx.update(inputRulesCtx, (irs) => irs.filter((x) => x !== ir))\n    }\n  }\n\n  return <$InputRule>plugin\n}\n\n/// The async version for `$inputRule`. You can use `await` in the factory when creating the input rule.\n///\n/// Additional property:\n/// - `inputRule`: The prosemirror input rule created.\n/// - `timer`: The timer which will be resolved when the input rule is ready.\nexport function $inputRuleAsync(\n  inputRule: (ctx: Ctx) => Promise<InputRule>,\n  timerName?: string\n) {\n  return addTimer<$InputRule>(\n    async (ctx, plugin) => {\n      await ctx.wait(SchemaReady)\n      const ir = await inputRule(ctx)\n      ctx.update(inputRulesCtx, (irs) => [...irs, ir])\n      plugin.inputRule = ir\n      return () => {\n        ctx.update(inputRulesCtx, (irs) => irs.filter((x) => x !== ir))\n      }\n    },\n    editorStateTimerCtx,\n    timerName\n  )\n}\n","import type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\n\nimport {\n  pasteRulesCtx,\n  pasteRulesTimerCtx,\n  SchemaReady,\n  type PasteRule,\n} from '@milkdown/core'\n\nimport { addTimer } from './utils'\n\n/// @internal\nexport type $PasteRule = MilkdownPlugin & {\n  pasteRule: PasteRule\n}\n\n/// Create a paste rule plugin.\n/// It takes a factory function which returns a paste rule.\n///\n/// Additional property:\n/// - `pasteRule`: The paste rule created.\nexport function $pasteRule(pasteRule: (ctx: Ctx) => PasteRule): $PasteRule {\n  const plugin: MilkdownPlugin = (ctx) => async () => {\n    await ctx.wait(SchemaReady)\n    const pr = pasteRule(ctx)\n    ctx.update(pasteRulesCtx, (prs) => [...prs, pr])\n    ;(<$PasteRule>plugin).pasteRule = pr\n\n    return () => {\n      ctx.update(pasteRulesCtx, (prs) => prs.filter((x) => x !== pr))\n    }\n  }\n\n  return <$PasteRule>plugin\n}\n\n/// The async version for `$pasteRule`. You can use `await` in the factory when creating the paste rule.\n///\n/// Additional property:\n/// - `pasteRule`: The paste rule created.\n/// - `timer`: The timer which will be resolved when the paste rule is ready.\nexport function $pasteRuleAsync(\n  pasteRule: (ctx: Ctx) => Promise<PasteRule>,\n  timerName?: string\n) {\n  return addTimer<$PasteRule>(\n    async (ctx, plugin) => {\n      await ctx.wait(SchemaReady)\n      const pr = await pasteRule(ctx)\n      ctx.update(pasteRulesCtx, (prs) => [...prs, pr])\n      plugin.pasteRule = pr\n      return () => {\n        ctx.update(pasteRulesCtx, (prs) => prs.filter((x) => x !== pr))\n      }\n    },\n    pasteRulesTimerCtx,\n    timerName\n  )\n}\n","import type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\nimport type { MarkType } from '@milkdown/prose/model'\nimport type { MarkSchema } from '@milkdown/transformer'\n\nimport { marksCtx, schemaCtx, schemaTimerCtx } from '@milkdown/core'\nimport { missingMarkInSchema } from '@milkdown/exception'\n\nimport { addTimer } from './utils'\n\n/// @internal\nexport type $Mark = MilkdownPlugin & {\n  id: string\n  schema: MarkSchema\n  type: (ctx: Ctx) => MarkType\n}\n\n/// Create a mark plugin.\n/// It takes a mark id and a factory function.\n/// The factory should return a function that returns a [mark schema](/transformer#interface-markschema).\n///\n/// Additional property:\n/// - `id`: The id of the mark.\n/// - `schema`: The mark schema created.\n/// - `type`: A function that will return the [prosemirror mark type](https://prosemirror.net/docs/ref/#model.MarkType).\nexport function $mark(id: string, schema: (ctx: Ctx) => MarkSchema): $Mark {\n  const plugin: MilkdownPlugin = (ctx) => async () => {\n    const markSchema = schema(ctx)\n    ctx.update(marksCtx, (ns) => [\n      ...ns.filter((n) => n[0] !== id),\n      [id, markSchema] as [string, MarkSchema],\n    ])\n    ;(<$Mark>plugin).id = id\n    ;(<$Mark>plugin).schema = markSchema\n\n    return () => {\n      ctx.update(marksCtx, (ns) => ns.filter(([x]) => x !== id))\n    }\n  }\n  ;(<$Mark>plugin).type = (ctx) => {\n    const markType = ctx.get(schemaCtx).marks[id]\n    if (!markType) throw missingMarkInSchema(id)\n    return markType\n  }\n\n  return <$Mark>plugin\n}\n\n/// The async version for `$mark`. You can use `await` in the factory when creating the mark schema.\n///\n/// Additional property:\n/// - `id`: The id of the mark.\n/// - `schema`: The mark schema created.\n/// - `type`: A function that will return the [prosemirror mark type](https://prosemirror.net/docs/ref/#model.MarkType).\n/// - `timer`: The timer which will be resolved when the mark schema is ready.\nexport function $markAsync(\n  id: string,\n  schema: (ctx: Ctx) => Promise<MarkSchema>,\n  timerName?: string\n) {\n  const plugin = addTimer<$Mark>(\n    async (ctx, plugin, done) => {\n      const markSchema = await schema(ctx)\n      ctx.update(marksCtx, (ns) => [\n        ...ns.filter((n) => n[0] !== id),\n        [id, markSchema] as [string, MarkSchema],\n      ])\n\n      plugin.id = id\n      plugin.schema = markSchema\n      done()\n\n      return () => {\n        ctx.update(marksCtx, (ns) => ns.filter(([x]) => x !== id))\n      }\n    },\n    schemaTimerCtx,\n    timerName\n  )\n\n  plugin.type = (ctx) => {\n    const markType = ctx.get(schemaCtx).marks[id]\n    if (!markType) throw missingMarkInSchema(id)\n    return markType\n  }\n\n  return plugin\n}\n","import type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\nimport type { NodeType } from '@milkdown/prose/model'\nimport type { NodeSchema } from '@milkdown/transformer'\n\nimport { nodesCtx, schemaCtx, schemaTimerCtx } from '@milkdown/core'\nimport { missingNodeInSchema } from '@milkdown/exception'\n\nimport { addTimer } from './utils'\n\n/// @internal\nexport type $Node = MilkdownPlugin & {\n  id: string\n  schema: NodeSchema\n  type: (ctx: Ctx) => NodeType\n}\n\n/// Create a node plugin.\n/// It takes a node id and a factory function.\n/// The factory should return a function that returns a [node schema](/transformer#interface-nodeschema).\n///\n/// Additional property:\n/// - `id`: The id of the node.\n/// - `schema`: The node schema created.\n/// - `type`: A function that will return the [prosemirror node type](https://prosemirror.net/docs/ref/#model.NodeType).\nexport function $node(id: string, schema: (ctx: Ctx) => NodeSchema): $Node {\n  const plugin: MilkdownPlugin = (ctx) => async () => {\n    const nodeSchema = schema(ctx)\n    ctx.update(nodesCtx, (ns) => [\n      ...ns.filter((n) => n[0] !== id),\n      [id, nodeSchema] as [string, NodeSchema],\n    ])\n    ;(<$Node>plugin).id = id\n    ;(<$Node>plugin).schema = nodeSchema\n\n    return () => {\n      ctx.update(nodesCtx, (ns) => ns.filter(([x]) => x !== id))\n    }\n  }\n\n  ;(<$Node>plugin).type = (ctx) => {\n    const nodeType = ctx.get(schemaCtx).nodes[id]\n    if (!nodeType) throw missingNodeInSchema(id)\n\n    return nodeType\n  }\n\n  return <$Node>plugin\n}\n\n/// The async version for `$node`. You can use `await` in the factory when creating the node schema.\n///\n/// Additional property:\n/// - `id`: The id of the node.\n/// - `schema`: The node schema created.\n/// - `type`: A function that will return the [prosemirror node type](https://prosemirror.net/docs/ref/#model.NodeType).\n/// - `timer`: The timer which will be resolved when the node schema is ready.\nexport function $nodeAsync(\n  id: string,\n  schema: (ctx: Ctx) => Promise<NodeSchema>,\n  timerName?: string\n) {\n  const plugin = addTimer<$Node>(\n    async (ctx, plugin, done) => {\n      const nodeSchema = await schema(ctx)\n      ctx.update(nodesCtx, (ns) => [\n        ...ns.filter((n) => n[0] !== id),\n        [id, nodeSchema] as [string, NodeSchema],\n      ])\n\n      plugin.id = id\n      plugin.schema = nodeSchema\n      done()\n\n      return () => {\n        ctx.update(nodesCtx, (ns) => ns.filter(([x]) => x !== id))\n      }\n    },\n    schemaTimerCtx,\n    timerName\n  )\n\n  plugin.type = (ctx) => {\n    const nodeType = ctx.get(schemaCtx).nodes[id]\n    if (!nodeType) throw missingNodeInSchema(id)\n\n    return nodeType\n  }\n\n  return plugin\n}\n","import type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\nimport type { Plugin, PluginKey } from '@milkdown/prose/state'\n\nimport {\n  SchemaReady,\n  editorStateTimerCtx,\n  prosePluginsCtx,\n} from '@milkdown/core'\n\nimport { addTimer } from './utils'\n\n/// @internal\nexport type $Prose = MilkdownPlugin & {\n  plugin: () => Plugin\n  key: () => PluginKey | undefined\n}\n\n/// Create a milkdown wrapper for [prosemirror plugin](https://prosemirror.net/docs/ref/#state.Plugin).\n/// It takes a factory function which returns a [prosemirror plugin](https://prosemirror.net/docs/ref/#state.Plugin).\n///\n/// Additional property:\n/// - `plugin`: The prosemirror plugin created.\n/// - `key`: The [prosemirror plugin key](https://prosemirror.net/docs/ref/#state.PluginKey) of the plugin.\nexport function $prose(prose: (ctx: Ctx) => Plugin): $Prose {\n  let prosePlugin: Plugin | undefined\n  const plugin: MilkdownPlugin = (ctx) => async () => {\n    await ctx.wait(SchemaReady)\n    prosePlugin = prose(ctx)\n    ctx.update(prosePluginsCtx, (ps) => [...ps, prosePlugin!])\n\n    return () => {\n      ctx.update(prosePluginsCtx, (ps) => ps.filter((x) => x !== prosePlugin))\n    }\n  }\n  ;(<$Prose>plugin).plugin = () => prosePlugin!\n  ;(<$Prose>plugin).key = () => prosePlugin!.spec.key\n\n  return <$Prose>plugin\n}\n\n/// The async version for `$prose`. You can use `await` in the factory when creating the plugin.\n///\n/// Additional property:\n/// - `plugin`: The prosemirror plugin created.\n/// - `key`: The [prosemirror plugin key](https://prosemirror.net/docs/ref/#state.PluginKey) of the plugin.\n/// - `timer`: The timer which will be resolved when the plugin is ready.\nexport function $proseAsync(\n  prose: (ctx: Ctx) => Promise<Plugin>,\n  timerName?: string\n) {\n  let prosePlugin: Plugin | undefined\n  const plugin = addTimer<$Prose>(\n    async (ctx) => {\n      await ctx.wait(SchemaReady)\n      prosePlugin = await prose(ctx)\n      ctx.update(prosePluginsCtx, (ps) => [...ps, prosePlugin!])\n\n      return () => {\n        ctx.update(prosePluginsCtx, (ps) => ps.filter((x) => x !== prosePlugin))\n      }\n    },\n    editorStateTimerCtx,\n    timerName\n  )\n\n  plugin.plugin = () => prosePlugin!\n  plugin.key = () => prosePlugin!.spec.key\n\n  return plugin\n}\n","import type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\nimport type { Command } from '@milkdown/prose/state'\n\nimport {\n  KeymapReady,\n  editorStateTimerCtx,\n  keymapCtx,\n  type KeymapItem,\n} from '@milkdown/core'\n\nimport { addTimer } from './utils'\n\n/// @internal\nexport type Keymap = Record<string, Command | KeymapItem>\n\n/// @internal\nexport type $Shortcut = MilkdownPlugin & {\n  keymap: Keymap\n}\n\n/// Create a shortcut for the editor.\n/// It takes a factory function which returns a [prosemirror keymap](https://prosemirror.net/docs/ref/#keymap).\n///\n/// Additional property:\n/// - `keymap`: The prosemirror keymap created.\nexport function $shortcut(shortcut: (ctx: Ctx) => Keymap): $Shortcut {\n  const plugin: MilkdownPlugin = (ctx) => async () => {\n    await ctx.wait(KeymapReady)\n    const km = ctx.get(keymapCtx)\n    const keymap = shortcut(ctx)\n    const dispose = km.addObjectKeymap(keymap)\n    ;(<$Shortcut>plugin).keymap = keymap\n\n    return () => {\n      dispose()\n    }\n  }\n\n  return <$Shortcut>plugin\n}\n\n/// The async version for `$shortcut`. You can use `await` in the factory when creating the keymap.\n///\n/// Additional property:\n/// - `keymap`: The prosemirror keymap created.\n/// - `timer`: The timer which will be resolved when the plugin is ready.\nexport function $shortcutAsync(\n  shortcut: (ctx: Ctx) => Promise<Keymap>,\n  timerName?: string\n) {\n  return addTimer<$Shortcut>(\n    async (ctx, plugin) => {\n      await ctx.wait(KeymapReady)\n      const km = ctx.get(keymapCtx)\n      const keymap = await shortcut(ctx)\n      const dispose = km.addObjectKeymap(keymap)\n      plugin.keymap = keymap\n\n      return () => {\n        dispose()\n      }\n    },\n    editorStateTimerCtx,\n    timerName\n  )\n}\n","import type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\nimport type {\n  MarkViewConstructor,\n  NodeViewConstructor,\n} from '@milkdown/prose/view'\n\nimport {\n  SchemaReady,\n  editorViewTimerCtx,\n  markViewCtx,\n  nodeViewCtx,\n} from '@milkdown/core'\nimport { NodeType } from '@milkdown/prose/model'\n\nimport type { $Mark, $Node } from '.'\n\nimport { addTimer } from './utils'\n\n/// @internal\nexport type $View<\n  T extends $Node | $Mark,\n  V extends NodeViewConstructor | MarkViewConstructor,\n> = MilkdownPlugin & {\n  view: V\n  type: T\n}\n\n/// @internal\nexport type GetConstructor<T extends $Node | $Mark> = T extends $Node\n  ? NodeViewConstructor\n  : T extends $Mark\n    ? MarkViewConstructor\n    : NodeViewConstructor | MarkViewConstructor\n\n/// Create a [prosemirror node/mark view](https://prosemirror.net/docs/ref/#view.NodeView) plugin.\n/// It takes two arguments\n/// - `type`: The node/mark plugin that needs to add a view.\n/// - `view`: The factory that creates the view. It should return a function that returns a [node/mark view constructor](https://prosemirror.net/docs/ref/#view.NodeView).\n///\n/// Additional property:\n/// - `view`: The view created.\n/// - `type`: The node/mark plugin that needs to add a view.\nexport function $view<\n  T extends $Node | $Mark,\n  V extends NodeViewConstructor | MarkViewConstructor = GetConstructor<T>,\n>(type: T, view: (ctx: Ctx) => V): $View<T, V> {\n  const plugin: MilkdownPlugin = (ctx) => async () => {\n    await ctx.wait(SchemaReady)\n    const v = view(ctx)\n    if (type.type(ctx) instanceof NodeType)\n      ctx.update(nodeViewCtx, (ps) => [\n        ...ps,\n        [type.id, v] as [string, NodeViewConstructor],\n      ])\n    else\n      ctx.update(markViewCtx, (ps) => [\n        ...ps,\n        [type.id, v] as [string, MarkViewConstructor],\n      ])\n    ;(<$View<T, V>>plugin).view = v\n    ;(<$View<T, V>>plugin).type = type\n\n    return () => {\n      if (type.type(ctx) instanceof NodeType)\n        ctx.update(nodeViewCtx, (ps) => ps.filter((x) => x[0] !== type.id))\n      else ctx.update(markViewCtx, (ps) => ps.filter((x) => x[0] !== type.id))\n    }\n  }\n\n  return <$View<T, V>>plugin\n}\n\n/// The async version for `$view`. You can use `await` in the factory when creating the view.\n///\n/// Additional property:\n/// - `view`: The view created.\n/// - `type`: The node/mark plugin that needs to add a view.\n/// - `timer`: The timer which will be resolved when the view is ready.\nexport function $viewAsync<\n  T extends $Node | $Mark,\n  V extends NodeViewConstructor | MarkViewConstructor = GetConstructor<T>,\n>(type: T, view: (ctx: Ctx) => Promise<V>, timerName?: string) {\n  return addTimer<$View<T, V>>(\n    async (ctx, plugin) => {\n      await ctx.wait(SchemaReady)\n      const v = await view(ctx)\n      if (type.type(ctx) instanceof NodeType)\n        ctx.update(nodeViewCtx, (ps) => [\n          ...ps,\n          [type.id, v] as [string, NodeViewConstructor],\n        ])\n      else\n        ctx.update(markViewCtx, (ps) => [\n          ...ps,\n          [type.id, v] as [string, MarkViewConstructor],\n        ])\n\n      plugin.view = v\n      plugin.type = type\n\n      return () => {\n        if (type.type(ctx) instanceof NodeType)\n          ctx.update(nodeViewCtx, (ps) => ps.filter((x) => x[0] !== type.id))\n        else ctx.update(markViewCtx, (ps) => ps.filter((x) => x[0] !== type.id))\n      }\n    },\n    editorViewTimerCtx,\n    timerName\n  )\n}\n","import type { MilkdownPlugin, SliceType } from '@milkdown/ctx'\n\nimport { createSlice } from '@milkdown/ctx'\n\n/// @internal\nexport type $Ctx<T, N extends string> = MilkdownPlugin & {\n  key: SliceType<T, N>\n}\n\n/// Create a slice plugin. The plugin will be registered in the `ctx` and can be accessed by other parts of the editor.\n/// ```ts\n/// const counterCtx = $ctx(0, 'counter');\n/// ```\n///\n/// Additional property:\n/// - `key`: The key of the slice.\nexport function $ctx<T, N extends string>(value: T, name: N): $Ctx<T, N> {\n  const slice = createSlice(value, name)\n  const plugin: $Ctx<T, N> = (ctx) => {\n    ctx.inject(slice)\n    return () => {\n      return () => {\n        ctx.remove(slice)\n      }\n    }\n  }\n\n  plugin.key = slice\n\n  return plugin\n}\n","import type { Ctx } from '@milkdown/ctx'\nimport type { NodeSchema } from '@milkdown/transformer'\n\nimport type { $Ctx } from '../$ctx'\nimport type { $Node } from '../$node'\n\nimport { $ctx } from '../$ctx'\nimport { $node } from '../$node'\n\n/// @internal\nexport type GetNodeSchema = (ctx: Ctx) => NodeSchema\n\n/// @internal\nexport type $NodeSchema<T extends string> = [\n  schemaCtx: $Ctx<GetNodeSchema, T>,\n  schema: $Node,\n] & {\n  id: $Node['id']\n  type: $Node['type']\n  node: $Node\n  ctx: $Ctx<GetNodeSchema, T>\n  key: $Ctx<GetNodeSchema, T>['key']\n  extendSchema: (\n    handler: (prev: GetNodeSchema) => GetNodeSchema\n  ) => $NodeSchema<T>\n}\n\n/// Create a plugin for node schema.\n/// The first parameter is the id of the node schema.\n/// The second parameter is the function that returns the node schema.\n///\n/// The function will return a plugin with additional properties:\n/// - `id`: The id of the node schema.\n/// - `type`: A function witch will return the type of the node schema.\n/// - `ctx`: The context of the node schema.\n/// - `node`: The node schema plugin.\n/// - `schema`: The node schema.\n/// - `key`: The key of slice which contains the node schema factory.\n/// - `extendSchema`: A function witch will return a plugin that can extend the node schema.\nexport function $nodeSchema<T extends string>(\n  id: T,\n  schema: GetNodeSchema\n): $NodeSchema<T> {\n  const schemaCtx = $ctx(schema, id)\n\n  const nodeSchema = $node(id, (ctx) => {\n    const userSchema = ctx.get(schemaCtx.key)\n    return userSchema(ctx)\n  })\n\n  const result = [schemaCtx, nodeSchema] as $NodeSchema<T>\n  result.id = nodeSchema.id\n  result.node = nodeSchema\n\n  result.type = (ctx: Ctx) => nodeSchema.type(ctx)\n  result.ctx = schemaCtx\n  result.key = schemaCtx.key\n  result.extendSchema = (handler) => {\n    const nextSchema = handler(schema)\n\n    return $nodeSchema(id, nextSchema)\n  }\n\n  return result\n}\n","import type { Ctx } from '@milkdown/ctx'\nimport type { MarkSchema } from '@milkdown/transformer'\n\nimport type { $Ctx } from '../$ctx'\nimport type { $Mark } from '../$mark'\n\nimport { $ctx } from '../$ctx'\nimport { $mark } from '../$mark'\n\n/// @internal\nexport type GetMarkSchema = (ctx: Ctx) => MarkSchema\n\n/// @internal\nexport type $MarkSchema<T extends string> = [\n  schemaCtx: $Ctx<GetMarkSchema, T>,\n  schema: $Mark,\n] & {\n  id: $Mark['id']\n  type: $Mark['type']\n  mark: $Mark\n  ctx: $Ctx<GetMarkSchema, T>\n  key: $Ctx<GetMarkSchema, T>['key']\n  extendSchema: (\n    handler: (prev: GetMarkSchema) => GetMarkSchema\n  ) => $MarkSchema<T>\n}\n\n/// Create a plugin for mark schema.\n/// The first parameter is the id of the mark schema.\n/// The second parameter is the function that returns the mark schema.\n///\n/// The function will return a plugin with additional properties:\n/// - `id`: The id of the mark schema.\n/// - `type`: A function witch will return the type of the mark schema.\n/// - `ctx`: The context of the mark schema.\n/// - `mark`: The mark schema plugin.\n/// - `schema`: The mark schema.\n/// - `key`: The key of slice which contains the mark schema factory.\n/// - `extendSchema`: A function witch will return a plugin that can extend the mark schema.\nexport function $markSchema<T extends string>(\n  id: T,\n  schema: GetMarkSchema\n): $MarkSchema<T> {\n  const schemaCtx = $ctx(schema, id)\n\n  const markSchema = $mark(id, (ctx) => {\n    const userSchema = ctx.get(schemaCtx.key)\n    return userSchema(ctx)\n  })\n\n  const result = [schemaCtx, markSchema] as $MarkSchema<T>\n  result.id = markSchema.id\n  result.mark = markSchema\n\n  result.type = (ctx: Ctx) => markSchema.type(ctx)\n  result.ctx = schemaCtx\n  result.key = schemaCtx.key\n  result.extendSchema = (handler) => {\n    const nextSchema = handler(schema)\n\n    return $markSchema(id, nextSchema)\n  }\n\n  return result\n}\n","import type { Ctx, SliceType } from '@milkdown/ctx'\nimport type { Command } from '@milkdown/prose/state'\n\nimport type { $Ctx } from '../$ctx'\nimport type { $Shortcut, Keymap } from '../$shortcut'\n\nimport { $ctx } from '../$ctx'\nimport { $shortcut } from '../$shortcut'\n\n/// @internal\nexport type KeymapConfig<K extends string> = Record<\n  K,\n  {\n    shortcuts: string | string[]\n    priority?: number\n  }\n>\n\n/// @internal\nexport interface KeymapItem {\n  shortcuts: string | string[]\n  priority?: number\n  command: (ctx: Ctx) => Command\n}\n\n/// @internal\nexport type UserKeymapConfig<Key extends string> = Record<Key, KeymapItem>\n\n/// @internal\nexport type $UserKeymap<N extends string, Key extends string> = [\n  $Ctx<KeymapConfig<Key>, `${N}Keymap`>,\n  $Shortcut,\n] & {\n  key: SliceType<KeymapConfig<Key>, `${N}Keymap`>\n  keymap: Keymap\n  ctx: $Ctx<KeymapConfig<Key>, `${N}Keymap`>\n  shortcuts: $Shortcut\n}\n\n/// Create a keymap which can be customized by user.\n/// It takes two arguments:\n/// - `name`: The name of the keymap.\n/// - `userKeymap`: The keymap config which contains the shortcuts and the command.\nexport function $useKeymap<N extends string, Key extends string>(\n  name: N,\n  userKeymap: UserKeymapConfig<Key>\n) {\n  const key = Object.fromEntries(\n    Object.entries<KeymapItem>(userKeymap).map(\n      ([key, { shortcuts, priority }]) => {\n        return [key, { shortcuts, priority }]\n      }\n    )\n  ) as KeymapConfig<Key>\n\n  const keymapDef = $ctx<KeymapConfig<Key>, `${N}Keymap`>(key, `${name}Keymap`)\n\n  const shortcuts = $shortcut((ctx) => {\n    const keys = ctx.get(keymapDef.key)\n\n    const keymapTuple = Object.entries<KeymapItem>(userKeymap).flatMap(\n      ([key, { command }]) => {\n        const target = keys[key as Key]\n        const targetKeys = [target.shortcuts].flat()\n        const priority = target.priority\n\n        return targetKeys.map(\n          (targetKey) =>\n            [\n              targetKey,\n              {\n                key: targetKey,\n                onRun: command,\n                priority,\n              },\n            ] as const\n        )\n      }\n    )\n\n    return Object.fromEntries(keymapTuple)\n  })\n\n  const result = [keymapDef, shortcuts] as $UserKeymap<N, Key>\n  result.ctx = keymapDef\n  result.shortcuts = shortcuts\n  result.key = keymapDef.key\n  result.keymap = shortcuts.keymap\n\n  return result\n}\n","import type { Mark, Node } from '@milkdown/prose/model'\n\nimport type { $Ctx } from '../$ctx'\n\nimport { $ctx } from '../$ctx'\n\n/// @internal\nexport type $NodeAttr = $Ctx<\n  (node: Node) => Record<string, any>,\n  `${string}Attr`\n>\n\n/// Create a slice which contains the attributes for node schema.\nexport const $nodeAttr = (\n  name: string,\n  value: (node: Node) => Record<string, any> = () => ({})\n): $NodeAttr => $ctx(value, `${name}Attr`)\n\n/// @internal\nexport type $MarkAttr = $Ctx<\n  (node: Mark) => Record<string, any>,\n  `${string}Attr`\n>\n\n/// Create a slice which contains the attributes for mark schema.\nexport const $markAttr = (\n  name: string,\n  value: (mark: Mark) => Record<string, any> = () => ({})\n): $MarkAttr => $ctx(value, `${name}Attr`)\n","import type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\nimport type { RemarkPlugin, RemarkPluginRaw } from '@milkdown/transformer'\n\nimport { InitReady, remarkPluginsCtx } from '@milkdown/core'\n\nimport type { $Ctx } from '../$ctx'\n\nimport { $ctx } from '../$ctx'\n\n/// @internal\nexport type $Remark<Id extends string, Options> = [\n  optionsCtx: $Ctx<Options, Id>,\n  plugin: MilkdownPlugin,\n] & {\n  id: Id\n  plugin: MilkdownPlugin\n  options: $Ctx<Options, Id>\n}\n\n/// Create a milkdown wrapper for [remark plugin](https://github.com/remarkjs/remark/blob/main/doc/plugins.md).\n/// It takes a factory function which returns a [remark plugin](https://github.com/remarkjs/remark/blob/main/doc/plugins.md).\n///\n/// Additional property:\n/// - `id`: The id of the remark plugin.\n/// - `plugin`: The remark plugin created.\n/// - `options`: The ctx contains the options of the remark plugin.\nexport function $remark<Id extends string, Options>(\n  id: Id,\n  remark: (ctx: Ctx) => RemarkPluginRaw<Options>,\n  initialOptions?: Options\n): $Remark<Id, Options> {\n  const options = $ctx<Options, Id>(initialOptions ?? ({} as Options), id)\n  const plugin: MilkdownPlugin = (ctx) => async () => {\n    await ctx.wait(InitReady)\n    const re = remark(ctx)\n    const remarkPlugin: RemarkPlugin<Options> = {\n      plugin: re,\n      options: ctx.get(options.key),\n    }\n    ctx.update(remarkPluginsCtx, (rp) => [...rp, remarkPlugin as RemarkPlugin])\n\n    return () => {\n      ctx.update(remarkPluginsCtx, (rp) => rp.filter((x) => x !== remarkPlugin))\n    }\n  }\n\n  const result = [options, plugin] as $Remark<Id, Options>\n  result.id = id\n  result.plugin = plugin\n  result.options = options\n\n  return result\n}\n","import type { CmdKey } from '@milkdown/core'\nimport type { Ctx } from '@milkdown/ctx'\n\nimport { commandsCtx } from '@milkdown/core'\n\ntype InferParams<T> = T extends CmdKey<infer U> ? U : never\n\n/// Call a command. You can pass the command key and the payload to the macro.\nexport function callCommand<T extends CmdKey<any>>(\n  slice: string,\n  payload?: InferParams<T>\n): (ctx: Ctx) => boolean\nexport function callCommand<T>(\n  slice: CmdKey<T>,\n  payload?: T\n): (ctx: Ctx) => boolean\nexport function callCommand(\n  slice: string | CmdKey<any>,\n  payload?: any\n): (ctx: Ctx) => boolean\nexport function callCommand(\n  slice: string | CmdKey<any>,\n  payload?: any\n): (ctx: Ctx) => boolean {\n  return (ctx: Ctx) => {\n    return ctx.get(commandsCtx).call(slice, payload)\n  }\n}\n","import type { Ctx } from '@milkdown/ctx'\n\nimport { editorViewCtx } from '@milkdown/core'\n\n/// Force update the editor.\nexport function forceUpdate() {\n  return (ctx: Ctx): void => {\n    const view = ctx.get(editorViewCtx)\n    const { tr } = view.state\n\n    const nextTr = Object.assign(Object.create(tr), tr).setTime(Date.now())\n    return view.dispatch(nextTr)\n  }\n}\n","import type { Ctx } from '@milkdown/ctx'\n\nimport { editorViewCtx, schemaCtx } from '@milkdown/core'\nimport { DOMSerializer } from '@milkdown/prose/model'\n\n/// Get content of the editor as HTML string.\nexport function getHTML() {\n  return (ctx: Ctx): string => {\n    const div = document.createElement('div')\n    const schema = ctx.get(schemaCtx)\n    const view = ctx.get(editorViewCtx)\n    const fragment = DOMSerializer.fromSchema(schema).serializeFragment(\n      view.state.doc.content\n    )\n\n    div.appendChild(fragment)\n\n    return div.innerHTML\n  }\n}\n","import type { Ctx } from '@milkdown/ctx'\n\nimport { editorViewCtx, schemaCtx, serializerCtx } from '@milkdown/core'\n\n/// Get content of the editor as markdown string.\n/// If range is provided, it will return the markdown string of the range.\n/// If range is not provided, it will return the markdown string of the whole document.\nexport function getMarkdown(range?: { from: number; to: number }) {\n  return (ctx: Ctx): string => {\n    const view = ctx.get(editorViewCtx)\n    const schema = ctx.get(schemaCtx)\n    const serializer = ctx.get(serializerCtx)\n\n    if (!range) {\n      return serializer(view.state.doc)\n    }\n\n    const state = view.state\n    const slice = state.doc.slice(range.from, range.to, true)\n    const doc = schema.topNodeType.createAndFill(null, slice.content)\n    if (!doc) {\n      console.error('No document found')\n      return ''\n    }\n    return serializer(doc)\n  }\n}\n","import type { Ctx } from '@milkdown/ctx'\n\nimport { editorViewCtx, parserCtx, schemaCtx } from '@milkdown/core'\nimport { isTextOnlySlice } from '@milkdown/prose'\nimport { DOMParser, DOMSerializer, Slice } from '@milkdown/prose/model'\n\n/// Insert markdown string into the editor.\nexport function insert(markdown: string, inline: boolean = false) {\n  return (ctx: Ctx) => {\n    const view = ctx.get(editorViewCtx)\n    const parser = ctx.get(parserCtx)\n    const doc = parser(markdown)\n    if (!doc) return\n\n    if (!inline) {\n      const contentSlice = view.state.selection.content()\n      return view.dispatch(\n        view.state.tr\n          .replaceSelection(\n            new Slice(doc.content, contentSlice.openStart, contentSlice.openEnd)\n          )\n          .scrollIntoView()\n      )\n    }\n\n    const schema = ctx.get(schemaCtx)\n    const dom = DOMSerializer.fromSchema(schema).serializeFragment(doc.content)\n    const domParser = DOMParser.fromSchema(schema)\n    const slice = domParser.parseSlice(dom)\n    const node = isTextOnlySlice(slice)\n    if (node) {\n      view.dispatch(view.state.tr.replaceSelectionWith(node, true))\n      return\n    }\n\n    view.dispatch(view.state.tr.replaceSelection(slice))\n  }\n}\n","import type { Ctx } from '@milkdown/ctx'\n\nimport { editorViewCtx } from '@milkdown/core'\n\n/// Get outline of the editor.\nexport function outline() {\n  return (ctx: Ctx): Array<{ text: string; level: number; id: string }> => {\n    const view = ctx.get(editorViewCtx)\n    const data: { text: string; level: number; id: string }[] = []\n    const doc = view.state.doc\n    doc.descendants((node) => {\n      if (node.type.name === 'heading' && node.attrs.level)\n        data.push({\n          text: node.textContent,\n          level: node.attrs.level,\n          id: node.attrs.id,\n        })\n    })\n    return data\n  }\n}\n","import type { Ctx } from '@milkdown/ctx'\n\nimport {\n  editorStateOptionsCtx,\n  editorViewCtx,\n  parserCtx,\n  prosePluginsCtx,\n  schemaCtx,\n} from '@milkdown/core'\nimport { Slice } from '@milkdown/prose/model'\nimport { EditorState } from '@milkdown/prose/state'\n\n/// Replace all content of the editor with markdown string.\n/// If flush is true, the editor state will be re-created.\nexport function replaceAll(markdown: string, flush = false) {\n  return (ctx: Ctx): void => {\n    const view = ctx.get(editorViewCtx)\n    const parser = ctx.get(parserCtx)\n    const doc = parser(markdown)\n    if (!doc) return\n\n    if (!flush) {\n      const { state } = view\n      return view.dispatch(\n        state.tr.replace(\n          0,\n          state.doc.content.size,\n          new Slice(doc.content, 0, 0)\n        )\n      )\n    }\n\n    const schema = ctx.get(schemaCtx)\n    const options = ctx.get(editorStateOptionsCtx)\n    const plugins = ctx.get(prosePluginsCtx)\n\n    const state = EditorState.create({\n      schema,\n      doc,\n      plugins,\n      ...options,\n    })\n\n    view.updateState(state)\n  }\n}\n","import type { Ctx } from '@milkdown/ctx'\nimport type { Attrs } from '@milkdown/prose/model'\n\nimport { editorViewCtx } from '@milkdown/core'\n\n/// Set the attributes of the node at the given position.\nexport function setAttr(pos: number, update: (prevAttrs: Attrs) => Attrs) {\n  return (ctx: Ctx) => {\n    const view = ctx.get(editorViewCtx)\n    const { tr } = view.state\n    const node = tr.doc.nodeAt(pos)\n    if (!node) return\n    const nextAttr = update(node.attrs)\n    return view.dispatch(tr.setNodeMarkup(pos, undefined, nextAttr))\n  }\n}\n","import type { Ctx } from '@milkdown/ctx'\n\nimport { parserCtx, schemaCtx } from '@milkdown/core'\nimport { DOMSerializer, DOMParser } from '@milkdown/prose/model'\n\n/// Convert markdown string to slice.\nexport function markdownToSlice(markdown: string) {\n  return (ctx: Ctx) => {\n    const parser = ctx.get(parserCtx)\n    const doc = parser(markdown)\n    const schema = ctx.get(schemaCtx)\n    const dom = DOMSerializer.fromSchema(schema).serializeFragment(doc.content)\n    const domParser = DOMParser.fromSchema(schema)\n    const slice = domParser.parseSlice(dom)\n\n    return slice\n  }\n}\n","import type { Ctx } from '@milkdown/ctx'\n\nimport { editorViewCtx } from '@milkdown/core'\n\nimport { markdownToSlice } from './markdown-to-slice'\n\n/// Insert markdown string to the given position.\n/// If inline is true, the markdown will be inserted as inline text.\n/// If inline is false, the markdown will be inserted as block text.\nexport function insertPos(\n  markdown: string,\n  pos: number,\n  inline: boolean = false\n) {\n  return (ctx: Ctx) => {\n    const slice = markdownToSlice(markdown)(ctx)\n    const view = ctx.get(editorViewCtx)\n    const toPos = view.state.doc.resolve(pos)\n\n    const min = 0\n    const max = view.state.doc.content.size\n    const resolved = inline ? toPos.pos : toPos.after(toPos.depth - 1)\n    const to = Math.min(Math.max(resolved, min), max)\n\n    view.dispatch(view.state.tr.replace(resolved, to, slice))\n  }\n}\n","import type { Ctx } from '@milkdown/ctx'\n\nimport { editorViewCtx } from '@milkdown/core'\n\nimport { markdownToSlice } from './markdown-to-slice'\n\n/// Replace the content of the given range with the markdown string.\nexport function replaceRange(\n  markdown: string,\n  range: { from: number; to: number }\n) {\n  return (ctx: Ctx) => {\n    const view = ctx.get(editorViewCtx)\n    const slice = markdownToSlice(markdown)(ctx)\n\n    view.dispatch(view.state.tr.replace(range.from, range.to, slice))\n  }\n}\n","/// @internal\nexport type Many<T> = T | ReadonlyArray<T>\n\ninterface Pipe {\n  pipe: (<A extends any[], R1, R2, R3, R4, R5, R6, R7>(\n    f1: (...args: A) => R1,\n    f2: (a: R1) => R2,\n    f3: (a: R2) => R3,\n    f4: (a: R3) => R4,\n    f5: (a: R4) => R5,\n    f6: (a: R5) => R6,\n    f7: (a: R6) => R7\n  ) => (...args: A) => R7) &\n    (<A extends any[], R1, R2, R3, R4, R5, R6, R7>(\n      f1: (...args: A) => R1,\n      f2: (a: R1) => R2,\n      f3: (a: R2) => R3,\n      f4: (a: R3) => R4,\n      f5: (a: R4) => R5,\n      f6: (a: R5) => R6,\n      f7: (a: R6) => R7,\n      ...func: Array<Many<(a: any) => any>>\n    ) => (...args: A) => any) &\n    (<A extends any[], R1, R2, R3, R4, R5, R6>(\n      f1: (...args: A) => R1,\n      f2: (a: R1) => R2,\n      f3: (a: R2) => R3,\n      f4: (a: R3) => R4,\n      f5: (a: R4) => R5,\n      f6: (a: R5) => R6\n    ) => (...args: A) => R6) &\n    (<A extends any[], R1, R2, R3, R4, R5>(\n      f1: (...args: A) => R1,\n      f2: (a: R1) => R2,\n      f3: (a: R2) => R3,\n      f4: (a: R3) => R4,\n      f5: (a: R4) => R5\n    ) => (...args: A) => R5) &\n    (<A extends any[], R1, R2, R3, R4>(\n      f1: (...args: A) => R1,\n      f2: (a: R1) => R2,\n      f3: (a: R2) => R3,\n      f4: (a: R3) => R4\n    ) => (...args: A) => R4) &\n    (<A extends any[], R1, R2, R3>(\n      f1: (...args: A) => R1,\n      f2: (a: R1) => R2,\n      f3: (a: R2) => R3\n    ) => (...args: A) => R3) &\n    (<A extends any[], R1, R2>(\n      f1: (...args: A) => R1,\n      f2: (a: R1) => R2\n    ) => (...args: A) => R2) &\n    ((...func: Array<Many<(...args: any[]) => any>>) => (...args: any[]) => any)\n}\n\n/// @internal\nexport const pipe: Pipe['pipe'] = (...funcs: any[]) => {\n  const length = funcs.length\n  let index = length\n  while (index--) {\n    if (typeof funcs[index] !== 'function')\n      throw new TypeError('Expected a function')\n  }\n  return (...args: any[]) => {\n    let index = 0\n    let result = length ? funcs[index](...args) : args[0]\n    while (++index < length) result = funcs[index](result)\n\n    return result\n  }\n}\n"],"names":["plugin","schemaCtx","key","shortcuts","state","index"],"mappings":"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"}