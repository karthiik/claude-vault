{"version":3,"file":"index.js","sources":["../src/__internal__/with-meta.ts","../src/mark/strike-through.ts","../src/node/table/schema.ts","../src/node/table/utils/create-table.ts","../src/node/table/utils/get-cells-in-col.ts","../src/node/table/utils/get-cells-in-row.ts","../src/node/table/utils/select-line.ts","../src/node/table/utils/add-row-with-alignment.ts","../src/node/table/utils/get-all-cells-in-table.ts","../src/node/table/utils/select-table.ts","../src/node/table/command.ts","../src/node/table/input.ts","../src/node/footnote/definition.ts","../src/node/footnote/reference.ts","../src/node/task-list-item.ts","../src/composed/keymap.ts","../src/composed/inputrules.ts","../src/composed/pasterules.ts","../src/plugin/auto-insert-span-plugin.ts","../src/plugin/column-resizing-plugin.ts","../src/plugin/table-editing-plugin.ts","../src/plugin/remark-gfm-plugin.ts","../src/plugin/keep-table-align-plugin.ts","../src/composed/plugins.ts","../src/composed/schema.ts","../src/composed/commands.ts","../src/index.ts"],"sourcesContent":["import type { Meta, MilkdownPlugin } from '@milkdown/ctx'\n\nexport function withMeta<T extends MilkdownPlugin>(\n  plugin: T,\n  meta: Partial<Meta> & Pick<Meta, 'displayName'>\n): T {\n  Object.assign(plugin, {\n    meta: {\n      package: '@milkdown/preset-gfm',\n      ...meta,\n    },\n  })\n\n  return plugin\n}\n","import { commandsCtx } from '@milkdown/core'\nimport { markRule } from '@milkdown/prose'\nimport { toggleMark } from '@milkdown/prose/commands'\nimport {\n  $command,\n  $inputRule,\n  $markAttr,\n  $markSchema,\n  $useKeymap,\n} from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for the strikethrough mark.\nexport const strikethroughAttr = $markAttr('strike_through')\n\nwithMeta(strikethroughAttr, {\n  displayName: 'Attr<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Strikethrough mark schema.\nexport const strikethroughSchema = $markSchema('strike_through', (ctx) => ({\n  parseDOM: [\n    { tag: 'del' },\n    {\n      style: 'text-decoration',\n      getAttrs: (value) => (value === 'line-through') as false,\n    },\n  ],\n  toDOM: (mark) => ['del', ctx.get(strikethroughAttr.key)(mark)],\n  parseMarkdown: {\n    match: (node) => node.type === 'delete',\n    runner: (state, node, markType) => {\n      state.openMark(markType)\n      state.next(node.children)\n      state.closeMark(markType)\n    },\n  },\n  toMarkdown: {\n    match: (mark) => mark.type.name === 'strike_through',\n    runner: (state, mark) => {\n      state.withMark(mark, 'delete')\n    },\n  },\n}))\n\nwithMeta(strikethroughSchema.mark, {\n  displayName: 'MarkSchema<strikethrough>',\n  group: 'Strikethrough',\n})\n\nwithMeta(strikethroughSchema.ctx, {\n  displayName: 'MarkSchemaCtx<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// A command to toggle the strikethrough mark.\nexport const toggleStrikethroughCommand = $command(\n  'ToggleStrikeThrough',\n  (ctx) => () => {\n    return toggleMark(strikethroughSchema.type(ctx))\n  }\n)\n\nwithMeta(toggleStrikethroughCommand, {\n  displayName: 'Command<ToggleStrikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Input rule to create the strikethrough mark.\nexport const strikethroughInputRule = $inputRule((ctx) => {\n  return markRule(\n    /(?<![\\w:/])(~{1,2})(.+?)\\1(?!\\w|\\/)/,\n    strikethroughSchema.type(ctx)\n  )\n})\n\nwithMeta(strikethroughInputRule, {\n  displayName: 'InputRule<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Keymap for the strikethrough mark.\n/// - `Mod-Alt-x` - Toggle the strikethrough mark.\nexport const strikethroughKeymap = $useKeymap('strikeThroughKeymap', {\n  ToggleStrikethrough: {\n    shortcuts: 'Mod-Alt-x',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(toggleStrikethroughCommand.key)\n    },\n  },\n})\n\nwithMeta(strikethroughKeymap.ctx, {\n  displayName: 'KeymapCtx<strikethrough>',\n  group: 'Strikethrough',\n})\n\nwithMeta(strikethroughKeymap.shortcuts, {\n  displayName: 'Keymap<strikethrough>',\n  group: 'Strikethrough',\n})\n","import type { NodeType } from '@milkdown/prose/model'\nimport type { MarkdownNode } from '@milkdown/transformer'\n\nimport { tableNodes } from '@milkdown/prose/tables'\nimport { $nodeSchema } from '@milkdown/utils'\n\nimport { withMeta } from '../../__internal__'\n\nconst originalSchema = tableNodes({\n  tableGroup: 'block',\n  cellContent: 'paragraph',\n  cellAttributes: {\n    alignment: {\n      default: 'left',\n      getFromDOM: (dom) => dom.style.textAlign || 'left',\n      setDOMAttr: (value, attrs) => {\n        attrs.style = `text-align: ${value || 'left'}`\n      },\n    },\n  },\n})\n\n/// Schema for table node.\nexport const tableSchema = $nodeSchema('table', () => ({\n  ...originalSchema.table,\n  content: 'table_header_row table_row+',\n  disableDropCursor: true,\n  parseMarkdown: {\n    match: (node) => node.type === 'table',\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align,\n        isHeader: i === 0,\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'table',\n    runner: (state, node) => {\n      const firstLine = node.content.firstChild?.content\n      if (!firstLine) return\n\n      const align: (string | null)[] = []\n      firstLine.forEach((cell) => {\n        align.push(cell.attrs.alignment)\n      })\n      state.openNode('table', undefined, { align })\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableSchema.node, {\n  displayName: 'NodeSchema<table>',\n  group: 'Table',\n})\n\nwithMeta(tableSchema.ctx, {\n  displayName: 'NodeSchemaCtx<table>',\n  group: 'Table',\n})\n\n/// Schema for table header row node.\nexport const tableHeaderRowSchema = $nodeSchema('table_header_row', () => ({\n  ...originalSchema.table_row,\n  disableDropCursor: true,\n  content: '(table_header)*',\n  parseDOM: [\n    { tag: 'tr[data-is-header]' },\n    {\n      tag: 'tr',\n      getAttrs: (dom: HTMLElement) => {\n        if (dom instanceof HTMLElement) {\n          const hasHeader = dom.querySelector('th')\n          return hasHeader ? {} : false\n        }\n        return false\n      },\n    },\n  ],\n  toDOM() {\n    return ['tr', { 'data-is-header': true }, 0]\n  },\n  parseMarkdown: {\n    match: (node) => Boolean(node.type === 'tableRow' && node.isHeader),\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align: align[i],\n        isHeader: node.isHeader,\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'table_header_row',\n    runner: (state, node) => {\n      state.openNode('tableRow', undefined, { isHeader: true })\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableHeaderRowSchema.node, {\n  displayName: 'NodeSchema<tableHeaderRow>',\n  group: 'Table',\n})\n\nwithMeta(tableHeaderRowSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableHeaderRow>',\n  group: 'Table',\n})\n\n/// Schema for table row node.\nexport const tableRowSchema = $nodeSchema('table_row', () => ({\n  ...originalSchema.table_row,\n  disableDropCursor: true,\n  content: '(table_cell)*',\n  parseMarkdown: {\n    match: (node) => node.type === 'tableRow',\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align: align[i],\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'table_row',\n    runner: (state, node) => {\n      // if the row is empty, we don't need to create a table row\n      // prevent remark from crashing\n      if (node.content.size === 0) {\n        return\n      }\n      state.openNode('tableRow')\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableRowSchema.node, {\n  displayName: 'NodeSchema<tableRow>',\n  group: 'Table',\n})\n\nwithMeta(tableRowSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableRow>',\n  group: 'Table',\n})\n\n/// Schema for table cell node.\nexport const tableCellSchema = $nodeSchema('table_cell', () => ({\n  ...originalSchema.table_cell,\n  disableDropCursor: true,\n  parseMarkdown: {\n    match: (node) => node.type === 'tableCell' && !node.isHeader,\n    runner: (state, node, type) => {\n      const align = node.align as string\n      state\n        .openNode(type, { alignment: align })\n        .openNode(state.schema.nodes.paragraph as NodeType)\n        .next(node.children)\n        .closeNode()\n        .closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'table_cell',\n    runner: (state, node) => {\n      state.openNode('tableCell').next(node.content).closeNode()\n    },\n  },\n}))\n\nwithMeta(tableCellSchema.node, {\n  displayName: 'NodeSchema<tableCell>',\n  group: 'Table',\n})\n\nwithMeta(tableCellSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableCell>',\n  group: 'Table',\n})\n\n/// Schema for table header node.\nexport const tableHeaderSchema = $nodeSchema('table_header', () => ({\n  ...originalSchema.table_header,\n  disableDropCursor: true,\n  parseMarkdown: {\n    match: (node) => node.type === 'tableCell' && !!node.isHeader,\n    runner: (state, node, type) => {\n      const align = node.align as string\n      state.openNode(type, { alignment: align })\n      state.openNode(state.schema.nodes.paragraph as NodeType)\n      state.next(node.children)\n      state.closeNode()\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'table_header',\n    runner: (state, node) => {\n      state.openNode('tableCell')\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableHeaderSchema.node, {\n  displayName: 'NodeSchema<tableHeader>',\n  group: 'Table',\n})\n\nwithMeta(tableHeaderSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableHeader>',\n  group: 'Table',\n})\n","import type { Ctx } from '@milkdown/ctx'\nimport type { Node } from '@milkdown/prose/model'\n\nimport {\n  tableCellSchema,\n  tableHeaderRowSchema,\n  tableHeaderSchema,\n  tableRowSchema,\n  tableSchema,\n} from '../schema'\n\n/// @internal\nexport function createTable(ctx: Ctx, rowsCount = 3, colsCount = 3): Node {\n  const cells = Array(colsCount)\n    .fill(0)\n    .map(() => tableCellSchema.type(ctx).createAndFill()!)\n\n  const headerCells = Array(colsCount)\n    .fill(0)\n    .map(() => tableHeaderSchema.type(ctx).createAndFill()!)\n\n  const rows = Array(rowsCount)\n    .fill(0)\n    .map((_, i) =>\n      i === 0\n        ? tableHeaderRowSchema.type(ctx).create(null, headerCells)\n        : tableRowSchema.type(ctx).create(null, cells)\n    )\n\n  return tableSchema.type(ctx).create(null, rows)\n}\n","import type { Selection } from '@milkdown/prose/state'\n\nimport { findTable, TableMap } from '@milkdown/prose/tables'\n\nimport type { CellPos } from './types'\n\n/// Get cells in a column of a table.\nexport function getCellsInCol(\n  columnIndexes: number | number[],\n  selection: Selection\n): CellPos[] | undefined {\n  const table = findTable(selection.$from)\n  if (!table) return undefined\n\n  const map = TableMap.get(table.node)\n  const indexes = Array.isArray(columnIndexes) ? columnIndexes : [columnIndexes]\n\n  return indexes\n    .filter((index) => index >= 0 && index <= map.width - 1)\n    .flatMap((index) => {\n      const cells = map.cellsInRect({\n        left: index,\n        right: index + 1,\n        top: 0,\n        bottom: map.height,\n      })\n      return cells.map((nodePos) => {\n        const node = table.node.nodeAt(nodePos)!\n        const pos = nodePos + table.start\n        return { pos, start: pos + 1, node, depth: table.depth + 2 }\n      })\n    })\n}\n","import type { Selection } from '@milkdown/prose/state'\n\nimport { findTable, TableMap } from '@milkdown/prose/tables'\n\nimport type { CellPos } from './types'\n\n/// Get cells in a row of a table.\nexport function getCellsInRow(\n  rowIndex: number | number[],\n  selection: Selection\n): CellPos[] | undefined {\n  const table = findTable(selection.$from)\n  if (!table) {\n    return\n  }\n\n  const map = TableMap.get(table.node)\n  const indexes = Array.isArray(rowIndex) ? rowIndex : [rowIndex]\n\n  return indexes\n    .filter((index) => index >= 0 && index <= map.height - 1)\n    .flatMap((index) => {\n      const cells = map.cellsInRect({\n        left: 0,\n        right: map.width,\n        top: index,\n        bottom: index + 1,\n      })\n      return cells.map((nodePos) => {\n        const node = table.node.nodeAt(nodePos)!\n        const pos = nodePos + table.start\n        return { pos, start: pos + 1, node, depth: table.depth + 2 }\n      })\n    })\n}\n","import type { Selection, Transaction } from '@milkdown/prose/state'\n\nimport { cloneTr, findParentNodeClosestToPos } from '@milkdown/prose'\nimport { CellSelection, TableMap } from '@milkdown/prose/tables'\n\n/// @internal\nexport function selectLine(type: 'row' | 'col') {\n  return (index: number, pos?: number) => (tr: Transaction) => {\n    pos = pos ?? tr.selection.from\n    const $pos = tr.doc.resolve(pos)\n    const $node = findParentNodeClosestToPos(\n      (node) => node.type.name === 'table'\n    )($pos)\n    const table = $node\n      ? {\n          node: $node.node,\n          from: $node.start,\n        }\n      : undefined\n\n    const isRowSelection = type === 'row'\n    if (table) {\n      const map = TableMap.get(table.node)\n\n      // Check if the index is valid\n      if (index >= 0 && index < (isRowSelection ? map.height : map.width)) {\n        const lastCell = map.positionAt(\n          isRowSelection ? index : map.height - 1,\n          isRowSelection ? map.width - 1 : index,\n          table.node\n        )\n        const $lastCell = tr.doc.resolve(table.from + lastCell)\n\n        const createCellSelection = isRowSelection\n          ? CellSelection.rowSelection\n          : CellSelection.colSelection\n\n        const firstCell = map.positionAt(\n          isRowSelection ? index : 0,\n          isRowSelection ? 0 : index,\n          table.node\n        )\n        const $firstCell = tr.doc.resolve(table.from + firstCell)\n        return cloneTr(\n          tr.setSelection(\n            createCellSelection($lastCell, $firstCell) as unknown as Selection\n          )\n        )\n      }\n    }\n    return tr\n  }\n}\n\n/// If the selection is in a table,\n/// select the {index} row.\nexport const selectRow = selectLine('row')\n\n/// If the selection is in a table,\n/// select the {index} column.\nexport const selectCol = selectLine('col')\n","import type { Ctx } from '@milkdown/ctx'\nimport type { Node } from '@milkdown/prose/model'\nimport type { Transaction } from '@milkdown/prose/state'\nimport type { TableRect } from '@milkdown/prose/tables'\n\nimport { tableCellSchema, tableRowSchema } from '../schema'\n\n/// @internal\nexport function addRowWithAlignment(\n  ctx: Ctx,\n  tr: Transaction,\n  { map, tableStart, table }: TableRect,\n  row: number\n) {\n  const rowPos = Array(row)\n    .fill(0)\n    .reduce((acc, _, i) => {\n      return acc + table.child(i).nodeSize\n    }, tableStart)\n\n  const cells = Array(map.width)\n    .fill(0)\n    .map((_, col) => {\n      const headerCol = table.nodeAt(map.map[col] as number)\n      return tableCellSchema\n        .type(ctx)\n        .createAndFill({ alignment: headerCol?.attrs.alignment }) as Node\n    })\n\n  tr.insert(rowPos, tableRowSchema.type(ctx).create(null, cells))\n  return tr\n}\n","import type { Selection } from '@milkdown/prose/state'\n\nimport { findTable, TableMap } from '@milkdown/prose/tables'\n\n/// Get all cells in a table.\nexport function getAllCellsInTable(selection: Selection) {\n  const table = findTable(selection.$from)\n  if (!table) return\n\n  const map = TableMap.get(table.node)\n  const cells = map.cellsInRect({\n    left: 0,\n    right: map.width,\n    top: 0,\n    bottom: map.height,\n  })\n  return cells.map((nodePos) => {\n    const node = table.node.nodeAt(nodePos)\n    const pos = nodePos + table.start\n    return { pos, start: pos + 1, node }\n  })\n}\n","import type { Transaction } from '@milkdown/prose/state'\n\nimport { cloneTr } from '@milkdown/prose'\nimport { CellSelection } from '@milkdown/prose/tables'\n\nimport { getAllCellsInTable } from './get-all-cells-in-table'\n\n/// Select a possible table in current selection.\nexport function selectTable(tr: Transaction) {\n  const cells = getAllCellsInTable(tr.selection)\n  if (cells && cells[0]) {\n    const $firstCell = tr.doc.resolve(cells[0].pos)\n    const last = cells[cells.length - 1]\n    if (last) {\n      const $lastCell = tr.doc.resolve(last.pos)\n      return cloneTr(tr.setSelection(new CellSelection($lastCell, $firstCell)))\n    }\n  }\n  return tr\n}\n","import { paragraphSchema } from '@milkdown/preset-commonmark'\nimport { findParentNodeType } from '@milkdown/prose'\nimport { Selection } from '@milkdown/prose/state'\nimport {\n  CellSelection,\n  addColumnAfter,\n  addColumnBefore,\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  goToNextCell,\n  isInTable,\n  selectedRect,\n  setCellAttr,\n  moveTableRow,\n  moveTableColumn,\n} from '@milkdown/prose/tables'\nimport { $command } from '@milkdown/utils'\n\nimport { withMeta } from '../../__internal__'\nimport { tableSchema } from './schema'\nimport {\n  addRowWithAlignment,\n  createTable,\n  selectCol,\n  selectRow,\n  selectTable,\n} from './utils'\n\n/// A command for moving cursor to previous cell.\nexport const goToPrevTableCellCommand = $command(\n  'GoToPrevTableCell',\n  () => () => goToNextCell(-1)\n)\n\nwithMeta(goToPrevTableCellCommand, {\n  displayName: 'Command<goToPrevTableCellCommand>',\n  group: 'Table',\n})\n\n/// A command for moving cursor to next cell.\nexport const goToNextTableCellCommand = $command(\n  'GoToNextTableCell',\n  () => () => goToNextCell(1)\n)\n\nwithMeta(goToNextTableCellCommand, {\n  displayName: 'Command<goToNextTableCellCommand>',\n  group: 'Table',\n})\n\n/// A command for quitting current table and insert a new paragraph node.\nexport const exitTable = $command(\n  'ExitTable',\n  (ctx) => () => (state, dispatch) => {\n    if (!isInTable(state)) return false\n\n    const { $head } = state.selection\n    const table = findParentNodeType($head, tableSchema.type(ctx))\n    if (!table) return false\n\n    const { to } = table\n\n    const tr = state.tr.replaceWith(\n      to,\n      to,\n      paragraphSchema.type(ctx).createAndFill()!\n    )\n\n    tr.setSelection(Selection.near(tr.doc.resolve(to), 1)).scrollIntoView()\n    dispatch?.(tr)\n    return true\n  }\n)\n\nwithMeta(exitTable, {\n  displayName: 'Command<breakTableCommand>',\n  group: 'Table',\n})\n\n/// A command for inserting a table.\n/// You can specify the number of rows and columns.\n/// By default, it will insert a 3x3 table.\nexport const insertTableCommand = $command(\n  'InsertTable',\n  (ctx) =>\n    ({ row, col }: { row?: number; col?: number } = {}) =>\n    (state, dispatch) => {\n      const { selection, tr } = state\n      const { from } = selection\n      const table = createTable(ctx, row, col)\n      const _tr = tr.replaceSelectionWith(table)\n      const sel = Selection.findFrom(_tr.doc.resolve(from), 1, true)\n      if (sel) _tr.setSelection(sel)\n\n      dispatch?.(_tr)\n\n      return true\n    }\n)\n\nwithMeta(insertTableCommand, {\n  displayName: 'Command<insertTableCommand>',\n  group: 'Table',\n})\n\n/// A command for moving a row in a table.\n/// You should specify the `from` and `to` index.\nexport const moveRowCommand = $command(\n  'MoveRow',\n  () =>\n    ({ from, to, pos }: { from?: number; to?: number; pos?: number } = {}) =>\n      moveTableRow({\n        from: from ?? 0,\n        to: to ?? 0,\n        pos,\n      })\n)\n\nwithMeta(moveRowCommand, {\n  displayName: 'Command<moveRowCommand>',\n  group: 'Table',\n})\n\n/// A command for moving a column in a table.\n/// You should specify the `from` and `to` index.\nexport const moveColCommand = $command(\n  'MoveCol',\n  () =>\n    ({ from, to, pos }: { from?: number; to?: number; pos?: number } = {}) =>\n      moveTableColumn({\n        from: from ?? 0,\n        to: to ?? 0,\n        pos,\n      })\n)\n\nwithMeta(moveColCommand, {\n  displayName: 'Command<moveColCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a row.\nexport const selectRowCommand = $command<\n  { index: number; pos?: number },\n  'SelectRow'\n>(\n  'SelectRow',\n  () =>\n    (payload: { index: number; pos?: number } = { index: 0 }) =>\n    (state, dispatch) => {\n      const { tr } = state\n      const result = dispatch?.(selectRow(payload.index, payload.pos)(tr))\n\n      return Boolean(result)\n    }\n)\n\nwithMeta(selectRowCommand, {\n  displayName: 'Command<selectRowCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a column.\nexport const selectColCommand = $command<\n  { index: number; pos?: number },\n  'SelectCol'\n>(\n  'SelectCol',\n  () =>\n    (payload: { index: number; pos?: number } = { index: 0 }) =>\n    (state, dispatch) => {\n      const { tr } = state\n      const result = dispatch?.(selectCol(payload.index, payload.pos)(tr))\n\n      return Boolean(result)\n    }\n)\n\nwithMeta(selectColCommand, {\n  displayName: 'Command<selectColCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a table.\nexport const selectTableCommand = $command(\n  'SelectTable',\n  () => () => (state, dispatch) => {\n    const { tr } = state\n    const result = dispatch?.(selectTable(tr))\n\n    return Boolean(result)\n  }\n)\n\nwithMeta(selectTableCommand, {\n  displayName: 'Command<selectTableCommand>',\n  group: 'Table',\n})\n\n/// A command for deleting selected cells.\n/// If the selection is a row or column, the row or column will be deleted.\n/// If all cells are selected, the table will be deleted.\nexport const deleteSelectedCellsCommand = $command(\n  'DeleteSelectedCells',\n  () => () => (state, dispatch) => {\n    const { selection } = state\n    if (!(selection instanceof CellSelection)) return false\n\n    const isRow = selection.isRowSelection()\n    const isCol = selection.isColSelection()\n\n    if (isRow && isCol) return deleteTable(state, dispatch)\n\n    if (isCol) return deleteColumn(state, dispatch)\n    else return deleteRow(state, dispatch)\n  }\n)\n\nwithMeta(deleteSelectedCellsCommand, {\n  displayName: 'Command<deleteSelectedCellsCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a column before the current column.\nexport const addColBeforeCommand = $command(\n  'AddColBefore',\n  () => () => addColumnBefore\n)\n\nwithMeta(addColBeforeCommand, {\n  displayName: 'Command<addColBeforeCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a column after the current column.\nexport const addColAfterCommand = $command(\n  'AddColAfter',\n  () => () => addColumnAfter\n)\n\nwithMeta(addColAfterCommand, {\n  displayName: 'Command<addColAfterCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a row before the current row.\nexport const addRowBeforeCommand = $command(\n  'AddRowBefore',\n  (ctx) => () => (state, dispatch) => {\n    if (!isInTable(state)) return false\n    if (dispatch) {\n      const rect = selectedRect(state)\n      dispatch(addRowWithAlignment(ctx, state.tr, rect, rect.top))\n    }\n    return true\n  }\n)\n\nwithMeta(addRowBeforeCommand, {\n  displayName: 'Command<addRowBeforeCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a row after the current row.\nexport const addRowAfterCommand = $command(\n  'AddRowAfter',\n  (ctx) => () => (state, dispatch) => {\n    if (!isInTable(state)) return false\n    if (dispatch) {\n      const rect = selectedRect(state)\n      dispatch(addRowWithAlignment(ctx, state.tr, rect, rect.bottom))\n    }\n    return true\n  }\n)\n\nwithMeta(addRowAfterCommand, {\n  displayName: 'Command<addRowAfterCommand>',\n  group: 'Table',\n})\n\n/// A command for setting alignment property for selected cells.\n/// You can specify the alignment as `left`, `center`, or `right`.\n/// It's `left` by default.\nexport const setAlignCommand = $command<\n  'left' | 'center' | 'right',\n  'SetAlign'\n>(\n  'SetAlign',\n  () =>\n    (alignment = 'left') =>\n      setCellAttr('alignment', alignment)\n)\n\nwithMeta(setAlignCommand, {\n  displayName: 'Command<setAlignCommand>',\n  group: 'Table',\n})\n","import { commandsCtx } from '@milkdown/core'\nimport { paragraphSchema } from '@milkdown/preset-commonmark'\nimport { InputRule } from '@milkdown/prose/inputrules'\nimport { Fragment, Slice } from '@milkdown/prose/model'\nimport { TextSelection } from '@milkdown/prose/state'\nimport { $inputRule, $pasteRule, $useKeymap } from '@milkdown/utils'\n\nimport { withMeta } from '../../__internal__'\nimport {\n  exitTable,\n  goToNextTableCellCommand,\n  goToPrevTableCellCommand,\n} from './command'\nimport { tableHeaderSchema, tableSchema } from './schema'\nimport { createTable } from './utils'\n\n/// A input rule for creating table.\n/// For example, `|2x2|` will create a 2x2 table.\nexport const insertTableInputRule = $inputRule(\n  (ctx) =>\n    new InputRule(\n      /^\\|(?<col>\\d+)[xX](?<row>\\d+)\\|\\s$/,\n      (state, match, start, end) => {\n        const $start = state.doc.resolve(start)\n        if (\n          !$start\n            .node(-1)\n            .canReplaceWith(\n              $start.index(-1),\n              $start.indexAfter(-1),\n              tableSchema.type(ctx)\n            )\n        )\n          return null\n\n        const row = Math.max(Number(match.groups?.row ?? 0), 2)\n\n        const tableNode = createTable(ctx, row, Number(match.groups?.col))\n        const tr = state.tr.replaceRangeWith(start, end, tableNode)\n        return tr\n          .setSelection(TextSelection.create(tr.doc, start + 3))\n          .scrollIntoView()\n      }\n    )\n)\n\nwithMeta(insertTableInputRule, {\n  displayName: 'InputRule<insertTableInputRule>',\n  group: 'Table',\n})\n\n/// A paste rule for fixing tables without header cells.\n/// This is a workaround for some editors (e.g. Google Docs) which allow creating tables without header cells,\n/// which is not supported by Markdown schema.\n/// This paste rule will add header cells to the first row if it's missing.\nexport const tablePasteRule = $pasteRule((ctx) => ({\n  run: (slice, _view, isPlainText) => {\n    if (isPlainText) {\n      return slice\n    }\n    let fragment = slice.content\n\n    slice.content.forEach((node, _offset, index) => {\n      if (node?.type !== tableSchema.type(ctx)) {\n        return\n      }\n      const rowsCount = node.childCount\n      const colsCount = node.lastChild?.childCount ?? 0\n      if (rowsCount === 0 || colsCount === 0) {\n        fragment = fragment.replaceChild(\n          index,\n          paragraphSchema.type(ctx).create()\n        )\n        return\n      }\n\n      const headerRow = node.firstChild\n      const needToFixHeaderRow =\n        colsCount > 0 && headerRow && headerRow.childCount === 0\n      if (!needToFixHeaderRow) {\n        return\n      }\n      // Fix for tables with rows but no cells in the first row\n      const headerCells = Array(colsCount)\n        .fill(0)\n        .map(() => tableHeaderSchema.type(ctx).createAndFill()!)\n\n      const tableCells = new Slice(Fragment.from(headerCells), 0, 0)\n\n      const newHeaderRow = headerRow.replace(0, 0, tableCells)\n      const newTable = node.replace(\n        0,\n        headerRow.nodeSize,\n        new Slice(Fragment.from(newHeaderRow), 0, 0)\n      )\n      fragment = fragment.replaceChild(index, newTable)\n    })\n\n    return new Slice(Fragment.from(fragment), slice.openStart, slice.openEnd)\n  },\n}))\n\nwithMeta(tablePasteRule, {\n  displayName: 'PasteRule<table>',\n  group: 'Table',\n})\n\n/// Keymap for table commands.\n/// - `<Mod-]>`/`<Tab>`: Move to the next cell.\n/// - `<Mod-[>`/`<Shift-Tab>`: Move to the previous cell.\n/// - `<Mod-Enter>`: Exit the table, and break it if possible.\nexport const tableKeymap = $useKeymap('tableKeymap', {\n  NextCell: {\n    priority: 100,\n    shortcuts: ['Mod-]', 'Tab'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(goToNextTableCellCommand.key)\n    },\n  },\n  PrevCell: {\n    shortcuts: ['Mod-[', 'Shift-Tab'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(goToPrevTableCellCommand.key)\n    },\n  },\n  ExitTable: {\n    shortcuts: ['Mod-Enter', 'Enter'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(exitTable.key)\n    },\n  },\n})\n\nwithMeta(tableKeymap.ctx, {\n  displayName: 'KeymapCtx<table>',\n  group: 'Table',\n})\n\nwithMeta(tableKeymap.shortcuts, {\n  displayName: 'Keymap<table>',\n  group: 'Table',\n})\n","import { expectDomTypeError } from '@milkdown/exception'\nimport { $nodeSchema } from '@milkdown/utils'\n\nimport { withMeta } from '../../__internal__'\n\nconst id = 'footnote_definition'\nconst markdownId = 'footnoteDefinition'\n\n/// Footnote definition node schema.\nexport const footnoteDefinitionSchema = $nodeSchema(\n  'footnote_definition',\n  () => ({\n    group: 'block',\n    content: 'block+',\n    defining: true,\n    attrs: {\n      label: {\n        default: '',\n        validate: 'string',\n      },\n    },\n    parseDOM: [\n      {\n        tag: `dl[data-type=\"${id}\"]`,\n        getAttrs: (dom) => {\n          if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n          return {\n            label: dom.dataset.label,\n          }\n        },\n        contentElement: 'dd',\n      },\n    ],\n    toDOM: (node) => {\n      const label = node.attrs.label\n\n      return [\n        'dl',\n        {\n          // TODO: add a prosemirror plugin to sync label on change\n          'data-label': label,\n          'data-type': id,\n        },\n        ['dt', label],\n        ['dd', 0],\n      ]\n    },\n    parseMarkdown: {\n      match: ({ type }) => type === markdownId,\n      runner: (state, node, type) => {\n        state\n          .openNode(type, {\n            label: node.label as string,\n          })\n          .next(node.children)\n          .closeNode()\n      },\n    },\n    toMarkdown: {\n      match: (node) => node.type.name === id,\n      runner: (state, node) => {\n        state\n          .openNode(markdownId, undefined, {\n            label: node.attrs.label,\n            identifier: node.attrs.label,\n          })\n          .next(node.content)\n          .closeNode()\n      },\n    },\n  })\n)\n\nwithMeta(footnoteDefinitionSchema.ctx, {\n  displayName: 'NodeSchemaCtx<footnodeDef>',\n  group: 'footnote',\n})\n\nwithMeta(footnoteDefinitionSchema.node, {\n  displayName: 'NodeSchema<footnodeDef>',\n  group: 'footnote',\n})\n","import { expectDomTypeError } from '@milkdown/exception'\nimport { $nodeSchema } from '@milkdown/utils'\n\nimport { withMeta } from '../../__internal__'\n\nconst id = 'footnote_reference'\n\n/// Footnote reference node schema.\nexport const footnoteReferenceSchema = $nodeSchema(\n  'footnote_reference',\n  () => ({\n    group: 'inline',\n    inline: true,\n    atom: true,\n    attrs: {\n      label: {\n        default: '',\n        validate: 'string',\n      },\n    },\n    parseDOM: [\n      {\n        tag: `sup[data-type=\"${id}\"]`,\n        getAttrs: (dom) => {\n          if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n          return {\n            label: dom.dataset.label,\n          }\n        },\n      },\n    ],\n    toDOM: (node) => {\n      const label = node.attrs.label\n      return [\n        'sup',\n        {\n          // TODO: add a prosemirror plugin to sync label on change\n          'data-label': label,\n          'data-type': id,\n        },\n        label,\n      ]\n    },\n    parseMarkdown: {\n      match: ({ type }) => type === 'footnoteReference',\n      runner: (state, node, type) => {\n        state.addNode(type, {\n          label: node.label as string,\n        })\n      },\n    },\n    toMarkdown: {\n      match: (node) => node.type.name === id,\n      runner: (state, node) => {\n        state.addNode('footnoteReference', undefined, undefined, {\n          label: node.attrs.label,\n          identifier: node.attrs.label,\n        })\n      },\n    },\n  })\n)\n\nwithMeta(footnoteReferenceSchema.ctx, {\n  displayName: 'NodeSchemaCtx<footnodeRef>',\n  group: 'footnote',\n})\n\nwithMeta(footnoteReferenceSchema.node, {\n  displayName: 'NodeSchema<footnodeRef>',\n  group: 'footnote',\n})\n","import { expectDomTypeError } from '@milkdown/exception'\nimport { listItemSchema } from '@milkdown/preset-commonmark'\nimport { InputRule } from '@milkdown/prose/inputrules'\nimport { $inputRule } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// This schema extends the [list item](/preset-commonmark#list-item) schema and add task list support for it.\nexport const extendListItemSchemaForTask = listItemSchema.extendSchema(\n  (prev) => {\n    return (ctx) => {\n      const baseSchema = prev(ctx)\n      return {\n        ...baseSchema,\n        attrs: {\n          ...baseSchema.attrs,\n          checked: {\n            default: null,\n            validate: 'boolean|null',\n          },\n        },\n        parseDOM: [\n          {\n            tag: 'li[data-item-type=\"task\"]',\n            getAttrs: (dom) => {\n              if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n              return {\n                label: dom.dataset.label,\n                listType: dom.dataset.listType,\n                spread: dom.dataset.spread,\n                checked: dom.dataset.checked\n                  ? dom.dataset.checked === 'true'\n                  : null,\n              }\n            },\n          },\n          ...(baseSchema?.parseDOM || []),\n        ],\n        toDOM: (node) => {\n          if (baseSchema.toDOM && node.attrs.checked == null)\n            return baseSchema.toDOM(node)\n\n          return [\n            'li',\n            {\n              'data-item-type': 'task',\n              'data-label': node.attrs.label,\n              'data-list-type': node.attrs.listType,\n              'data-spread': node.attrs.spread,\n              'data-checked': node.attrs.checked,\n            },\n            0,\n          ]\n        },\n        parseMarkdown: {\n          match: ({ type }) => type === 'listItem',\n          runner: (state, node, type) => {\n            if (node.checked == null) {\n              baseSchema.parseMarkdown.runner(state, node, type)\n              return\n            }\n\n            const label = node.label != null ? `${node.label}.` : 'â€¢'\n            const checked = node.checked != null ? Boolean(node.checked) : null\n            const listType = node.label != null ? 'ordered' : 'bullet'\n            const spread = node.spread != null ? `${node.spread}` : 'true'\n\n            state.openNode(type, { label, listType, spread, checked })\n            state.next(node.children)\n            state.closeNode()\n          },\n        },\n        toMarkdown: {\n          match: (node) => node.type.name === 'list_item',\n          runner: (state, node) => {\n            if (node.attrs.checked == null) {\n              baseSchema.toMarkdown.runner(state, node)\n              return\n            }\n\n            const label = node.attrs.label\n            const listType = node.attrs.listType\n            const spread = node.attrs.spread === 'true'\n            const checked = node.attrs.checked\n\n            state.openNode('listItem', undefined, {\n              label,\n              listType,\n              spread,\n              checked,\n            })\n            state.next(node.content)\n            state.closeNode()\n          },\n        },\n      }\n    }\n  }\n)\n\nwithMeta(extendListItemSchemaForTask.node, {\n  displayName: 'NodeSchema<taskListItem>',\n  group: 'ListItem',\n})\n\nwithMeta(extendListItemSchemaForTask.ctx, {\n  displayName: 'NodeSchemaCtx<taskListItem>',\n  group: 'ListItem',\n})\n\n/// Input rule for wrapping a block in task list node.\n/// Users can type `[ ] ` or `[x] ` to wrap the block in task list node with checked status.\nexport const wrapInTaskListInputRule = $inputRule(() => {\n  return new InputRule(\n    /^\\[(?<checked>\\s|x)\\]\\s$/,\n    (state, match, start, end) => {\n      const pos = state.doc.resolve(start)\n      let depth = 0\n      let node = pos.node(depth)\n      while (node && node.type.name !== 'list_item') {\n        depth--\n        node = pos.node(depth)\n      }\n\n      if (!node || node.attrs.checked != null) return null\n\n      const checked = Boolean(match.groups?.checked === 'x')\n\n      const finPos = pos.before(depth)\n      const tr = state.tr\n\n      tr.deleteRange(start, end).setNodeMarkup(finPos, undefined, {\n        ...node.attrs,\n        checked,\n      })\n\n      return tr\n    }\n  )\n})\n\nwithMeta(wrapInTaskListInputRule, {\n  displayName: 'InputRule<wrapInTaskListInputRule>',\n  group: 'ListItem',\n})\n","import type { MilkdownPlugin } from '@milkdown/ctx'\n\nimport { strikethroughKeymap } from '../mark'\nimport { tableKeymap } from '../node'\n\n/// @internal\nexport const keymap: MilkdownPlugin[] = [\n  strikethroughKeymap,\n  tableKeymap,\n].flat()\n","import type { MilkdownPlugin } from '@milkdown/ctx'\n\nimport { strikethroughInputRule } from '../mark'\nimport { insertTableInputRule, wrapInTaskListInputRule } from '../node'\n\n/// @internal\nexport const inputRules: MilkdownPlugin[] = [\n  insertTableInputRule,\n  wrapInTaskListInputRule,\n]\n\nexport const markInputRules: MilkdownPlugin[] = [strikethroughInputRule]\n","import type { MilkdownPlugin } from '@milkdown/ctx'\n\nimport { tablePasteRule } from '../node'\n\n/// @internal\nexport const pasteRules: MilkdownPlugin[] = [tablePasteRule]\n","import { $prose } from '@milkdown/utils'\nimport { imeSpan } from 'prosemirror-safari-ime-span'\n\nimport { withMeta } from '../__internal__'\n\n/// This plugin is used to fix the bug of IME composing in table in Safari browser.\n/// original discussion in https://discuss.prosemirror.net/t/ime-composing-problems-on-td-or-th-element-in-safari-browser/4501\nexport const autoInsertSpanPlugin = $prose(() => imeSpan)\n\nwithMeta(autoInsertSpanPlugin, {\n  displayName: 'Prose<autoInsertSpanPlugin>',\n  group: 'Prose',\n})\n","import { columnResizing } from '@milkdown/prose/tables'\nimport { $prose } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the `columnResizing` plugin from [prosemirror-tables](https://github.com/ProseMirror/prosemirror-tables).\nexport const columnResizingPlugin = $prose(() => columnResizing({}))\n\nwithMeta(columnResizingPlugin, {\n  displayName: 'Prose<columnResizingPlugin>',\n  group: 'Prose',\n})\n","import { tableEditing } from '@milkdown/prose/tables'\nimport { $prose } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the `tableEditing` plugin from [prosemirror-tables](https://github.com/ProseMirror/prosemirror-tables).\nexport const tableEditingPlugin = $prose(() =>\n  tableEditing({ allowTableNodeSelection: true })\n)\n\nwithMeta(tableEditingPlugin, {\n  displayName: 'Prose<tableEditingPlugin>',\n  group: 'Prose',\n})\n","import type { $Remark } from '@milkdown/utils'\nimport type { Options } from 'remark-gfm'\n\nimport { $remark } from '@milkdown/utils'\nimport remarkGFM from 'remark-gfm'\n\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the [remark-gfm](https://github.com/remarkjs/remark-gfm).\nexport const remarkGFMPlugin: $Remark<'remarkGFM', Options | null | undefined> =\n  $remark('remarkGFM', () => remarkGFM)\n\nwithMeta(remarkGFMPlugin.plugin, {\n  displayName: 'Remark<remarkGFMPlugin>',\n  group: 'Remark',\n})\n\nwithMeta(remarkGFMPlugin.options, {\n  displayName: 'RemarkConfig<remarkGFMPlugin>',\n  group: 'Remark',\n})\n","import type { Node } from '@milkdown/prose/model'\nimport type { Transaction } from '@milkdown/prose/state'\n\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport { $prose } from '@milkdown/utils'\n\nimport { withMeta } from '../__internal__'\n\nconst pluginKey = new PluginKey('MILKDOWN_KEEP_TABLE_ALIGN_PLUGIN')\n\nfunction getChildIndex(node: Node, parent: Node) {\n  let index = 0\n  parent.forEach((child, _offset, i) => {\n    if (child === node) index = i\n  })\n  return index\n}\n\nexport const keepTableAlignPlugin = $prose(() => {\n  return new Plugin({\n    key: pluginKey,\n    appendTransaction: (_tr, oldState, state) => {\n      let tr: Transaction | undefined\n      const check = (node: Node, pos: number) => {\n        if (!tr) tr = state.tr\n\n        if (node.type.name !== 'table_cell') return\n\n        const $pos = state.doc.resolve(pos)\n        const tableRow = $pos.node($pos.depth)\n        const table = $pos.node($pos.depth - 1)\n        const tableHeaderRow = table.firstChild\n        // TODO: maybe consider add a header row\n        if (!tableHeaderRow) return\n\n        const index = getChildIndex(node, tableRow)\n        const headerCell = tableHeaderRow.maybeChild(index)\n        if (!headerCell) return\n        const align = headerCell.attrs.alignment\n        const currentAlign = node.attrs.alignment\n        if (align === currentAlign) return\n\n        tr.setNodeMarkup(pos, undefined, { ...node.attrs, alignment: align })\n      }\n      if (oldState.doc !== state.doc) state.doc.descendants(check)\n\n      return tr\n    },\n  })\n})\n\nwithMeta(keepTableAlignPlugin, {\n  displayName: 'Prose<keepTableAlignPlugin>',\n  group: 'Prose',\n})\n","import type { MilkdownPlugin } from '@milkdown/ctx'\n\nimport {\n  autoInsertSpanPlugin,\n  keepTableAlignPlugin,\n  remarkGFMPlugin,\n  tableEditingPlugin,\n} from '../plugin'\n\n/// @internal\nexport const plugins: MilkdownPlugin[] = [\n  keepTableAlignPlugin,\n  autoInsertSpanPlugin,\n  remarkGFMPlugin,\n  tableEditingPlugin,\n].flat()\n","import type { MilkdownPlugin } from '@milkdown/ctx'\n\nimport { strikethroughAttr, strikethroughSchema } from '../mark'\nimport {\n  extendListItemSchemaForTask,\n  footnoteDefinitionSchema,\n  footnoteReferenceSchema,\n  tableCellSchema,\n  tableHeaderRowSchema,\n  tableHeaderSchema,\n  tableRowSchema,\n  tableSchema,\n} from '../node'\n\n/// @internal\nexport const schema: MilkdownPlugin[] = [\n  extendListItemSchemaForTask,\n\n  tableSchema,\n  tableHeaderRowSchema,\n  tableRowSchema,\n  tableHeaderSchema,\n  tableCellSchema,\n\n  footnoteDefinitionSchema,\n  footnoteReferenceSchema,\n\n  strikethroughAttr,\n  strikethroughSchema,\n].flat()\n","import { toggleStrikethroughCommand } from '../mark'\nimport {\n  addColAfterCommand,\n  addColBeforeCommand,\n  addRowAfterCommand,\n  addRowBeforeCommand,\n  deleteSelectedCellsCommand,\n  exitTable,\n  goToNextTableCellCommand,\n  goToPrevTableCellCommand,\n  insertTableCommand,\n  moveColCommand,\n  moveRowCommand,\n  selectColCommand,\n  selectRowCommand,\n  selectTableCommand,\n  setAlignCommand,\n} from '../node'\n\n/// @internal\nexport const commands = [\n  goToNextTableCellCommand,\n  goToPrevTableCellCommand,\n  exitTable,\n  insertTableCommand,\n  moveRowCommand,\n  moveColCommand,\n  selectRowCommand,\n  selectColCommand,\n  selectTableCommand,\n  deleteSelectedCellsCommand,\n  addRowBeforeCommand,\n  addRowAfterCommand,\n  addColBeforeCommand,\n  addColAfterCommand,\n  setAlignCommand,\n\n  toggleStrikethroughCommand,\n]\n","import {\n  commands,\n  inputRules,\n  keymap,\n  markInputRules,\n  pasteRules,\n  plugins,\n  schema,\n} from './composed'\n\nexport * from './node'\nexport * from './mark'\nexport * from './plugin'\nexport * from './composed'\n\n/// The GFM preset, includes all the plugins.\nexport const gfm = [\n  schema,\n  inputRules,\n  pasteRules,\n  markInputRules,\n  keymap,\n  commands,\n  plugins,\n].flat()\n"],"names":["commands","id"],"mappings":"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"}